[{"content":"I redesigned a logo for Folder Slice, and i think it looks pretty good! ðŸ˜„\n","date":"2024-12-07T00:00:00Z","permalink":"https://hunterji.com/post/i-redesigned-a-icon-for-folder-slice/","title":"I redesigned a icon for Folder Slice"},{"content":" Your browser does not support the video tag. ","date":"2024-12-05T00:00:00Z","image":"https://hunterji.com/post/funny-design-exercise-p/cover_hu13241738419993079047.png","permalink":"https://hunterji.com/post/funny-design-exercise-p/","title":"Funny design exercise :P"},{"content":"My Environment The following development environment was used:\nXcode: 14\nSwift: 5.10\nDownload the Font If you are looking for a beautiful font, you can download fonts from Google Fonts.\nAdd the Font to Xcode Create a new folder named Fonts in project, and then drag the font file into it. Here, my font file named EduAUVICWANTHand-Regular.ttf.\nAdd the Font to the Info.plist In the Info.plist, create a new item named Fonts provided by application, then add the font filename to the first item. Note that you need to include the file extension here.\nAdd the Font to the CustomFont.swift Of course, you can also skip this step and use strings directly. However, for the convenience of management and use, it is recommended to handle them uniformly here. Create a new file named Models/CustomFont.swift , then complete it with the following code:\n1 2 3 4 5 6 7 8 9 import Foundation struct CustomFont: Identifiable { var id: UUID = UUID() var name: String var supportedLanguages: [String] = [\u0026#34;en\u0026#34;] static let EduAUVICWANTHandRegular = CustomFont(name: \u0026#34;EduAUVICWANTHand-Regular\u0026#34;) } Use The Font Now, we can use the new font.\n1 2 3 4 5 6 7 8 9 10 11 12 struct ContentView: View { var body: some View { VStack { Image(systemName: \u0026#34;globe\u0026#34;) .imageScale(.large) .foregroundStyle(.tint) Text(\u0026#34;Hello, world!\u0026#34;) .font(.custom(CustomFont.EduAUVICWANTHandRegular.name, size: 20)) // Use the new font } .padding() } } ","date":"2024-07-16T00:00:00Z","image":"https://hunterji.com/post/how-to-add-custom-fonts-to-swiftui-project-in-xcode/normal_hu3324909357741222847.jpg","permalink":"https://hunterji.com/post/how-to-add-custom-fonts-to-swiftui-project-in-xcode/","title":"How to add custom fonts to SwiftUI project in Xcode"},{"content":"Introduction In the previous article \u0026ldquo;Getting Fancy with Rust and WebAssembly (Part 3) - DOM Manipulation and Type Conversion\u0026rdquo;, we discussed the interaction between Rust and JS, including mutual function calls between Rust and JS. A particularly mind-blowing feature was using JS to call Rust structs. JS itself doesn\u0026rsquo;t even have structs, yet it can call Rust structs. This is really great for the development experience of Rust developers!\nBased on the previous series of articles, it\u0026rsquo;s already sufficient to develop a complete functionality using Rust.\nHowever, when importing wasm files in the frontend, there may still be some issues, such as large wasm files leading to longer webpage loading times and poor user experience. This article will explore various ways to reduce the size of Rust-compiled wasm files, thereby reducing the time it takes for the frontend to load wasm files.\nFor a while, I was using Go to develop WebAssembly, and the compiled wasm files were quite large. It was really painstaking to reduce the size of wasm files, and 1xMB size wasm files were really painful\u0026hellip;\u0026hellip; But size optimization often points to a \u0026ldquo;seductive point of no return\u0026rdquo; - switching to Rust development ðŸ˜†! If you\u0026rsquo;re already using Rust to develop WebAssembly, congratulations, you\u0026rsquo;re already winning at the starting line in terms of wasm size compared to Go.\nEnvironment Rust 1.70.0 wasm-bindgen 0.2.87 Checking the Size Before actually reducing the size, we need to first look at what the current size is, to facilitate later comparison of before and after sizes.\nThere are multiple ways to check the size, here are a few recommendations (for Linux and MacOS), you can use any one of them.\nls You can use ls -l or ll:\n1 2 $ ll pkg/hello_wasm_bg.wasm -rw-r--r-- 1 hunter staff 23K Jul 20 21:52 pkg/hello_wasm_bg.wasm stat 1 2 $ stat pkg/hello_wasm_bg.wasm 16777222 142141572 -rw-r--r-- 1 hunter staff 0 23347 \u0026#34;Jul 20 21:52:53 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; 4096 48 0 pkg/hello_wasm_bg.wasm wc 1 2 $ wc -c pkg/hello_wasm_bg.wasm 23347 pkg/hello_wasm_bg.wasm Using wc as an example, the current wasm file size is 23347b.\nCode Level Link-Time Optimization (LTO) refers to a type of interprocedural optimization performed during program linking. It allows the compiler to optimize across multiple compilation units during the linking phase, thereby improving the program\u0026rsquo;s performance, reliability, and security.\nOptimization at the code level mainly utilizes LTO (Link-Time Optimization).\nWithin the Code Enable LTO in Cargo.toml:\n1 2 [profile.release] lto = true Although enabling LTO can reduce the compiled size, it also increases compilation time.\nAfter enabling LTO, by default, it ensures compilation time while reducing the compiled size to a certain extent. If your requirement is for a smaller size rather than shorter time, then you can manually specify the compilation level to make LTO change.\nThe following levels can be used within the code:\ns: The default LTO level. It performs the most basic LTO optimizations, including function inlining, function rewriting, data rearrangement, etc. z: The highest LTO level. It performs more complex LTO optimizations, including dead code elimination, memory allocation optimization, security optimization, etc. So you can configure it in Cargo.toml like this:\n1 2 3 [profile.release] lto = true opt-level = \u0026#39;z\u0026#39; The original file size was 23347b, now let\u0026rsquo;s look at the size after compilation:\n1 2 $ wc -c pkg/hello_wasm_bg.wasm 19879 pkg/hello_wasm_bg.wasm It\u0026rsquo;s clearly reduced in size! However, using the z level doesn\u0026rsquo;t necessarily mean that the size will always be smaller than s, sometimes s can also be smaller than z, this needs to be determined based on the code situation.\nOutside the Code Outside the code, you can use wasm-opt for optimization. It can perform various optimizations on WebAssembly modules, of course, this article focuses on size aspects (digging a pit, we\u0026rsquo;ll discuss in detail later /dog head). And wasm-opt can optimize all wasm files that conform to the WebAssembly specification, so even if you didn\u0026rsquo;t write it in Rust, you can still use it for optimization. (Think about the wasm I used to write in Go, there\u0026rsquo;s also one more way to optimize it\u0026hellip;\u0026hellip;)\nFirst, let\u0026rsquo;s look at the basic optimization parameters of wasm-opt:\n-o: Specify the output file of the optimized module -O: Enable default optimization, equivalent to the -Os parameter -O0: No optimization -O1: Perform some basic optimizations, such as function inlining optimization and dead code elimination optimization -O2: Perform more thorough optimizations, such as function rewriting, data rearrangement, memory allocation optimization, etc. -O3: Perform the most thorough optimizations, including some optimizations that may affect program functionality -O4: Same as -O3, but will enable more aggressive optimizations -Os: The optimization goal is to reduce code size, will perform some optimizations that may affect performance -Oz: Same as -Os, but will enable more aggressive optimizations Based on the theme of this article, we will use the -Os and -Oz parameters here, which correspond to the levels in the above \u0026ldquo;Within the Code\u0026rdquo; section.\nHere, let\u0026rsquo;s execute with the -Oz parameter on the original wasm file, and see the comparison effect:\n1 2 $ wc -c pkg/output.wasm 23194 pkg/output.wasm Then let\u0026rsquo;s execute wasm-opt on the wasm file compiled after enabling \u0026ldquo;Within the Code\u0026rdquo; LTO, and see the comparison effect:\n1 2 $ wc -c pkg/output.wasm 19871 pkg/output.wasm Overall, the size of the wasm file is getting smaller and smaller. It\u0026rsquo;s just that the case I have here is using the code from the series of articles, without any actual complex code, and the size itself is already very small, so it won\u0026rsquo;t be particularly effective.\nNetwork Level At the network level, it\u0026rsquo;s the well-known compression of network transmission, where the client and server agree on the same compression algorithm, then the server compresses when sending out, and the client decompresses when receiving. Compression at the network level can compress the transmitted message without losing information.\nFor example, the gzip compression algorithm that everyone is familiar with, however, there are several compression algorithms:\ngzip compress deflate br Among them, gzip also has the highest compression rate, so here we\u0026rsquo;ll take gzip as an example.\nAt the network level, compress the wasm file with gzip to reduce its size during transmission. Although it reduces the size during transmission, the browser needs to consume some performance to decrypt the compressed data when it receives it.\nEnabling GZIP Enabling GZIP is actually simple, you just need to agree with the frontend and backend to both use gzip.\nFirst, when the frontend requests the wasm file, it needs to put the compression modes supported by the browser in the request header:\n1 Accept-Encoding: gzip, deflate Then, after the server receives this request, it can give out the compression modes that the server also supports, and tell the browser what compression mode the server will use.\nThe way to communicate with the browser is to put the information in the response header:\n1 Content-Encoding: gzip This enables GZIP.\nThen, the browser receives the response body and header, knows that the backend uses gzip compression, so the browser will automatically use gzip to decompress and get the complete data.\nServer Support You might wonder, the browser can automatically decrypt, but how does the server automatically encrypt? Does the backend need to write code to encrypt the file?\nOf course not, just let the http server complete this operation. Here we\u0026rsquo;ll take the familiar Nginx as an example.\nThe simplest is to enable gzip with one line of configuration:\n1 gzip on; You can also specify some parameters for gzip, such as the types that can be encrypted, the minimum encryption length, etc.:\n1 2 3 4 5 gzip on; gzip_types text/plain application/xml; gzip_proxied no-cache no-store private expired auth; gzip_min_length 1000; ... For more http server configurations, you can refer to their respective official documentation.\nPhysical Level You might be surprised, what physical level?!\nThat\u0026rsquo;s right, it\u0026rsquo;s really at the physical level - directly perform gzip physical compression on the wasm file! Haha, this method is really amazing, I discovered it when I was looking for ways to reduce size while developing wasm with Go. If you\u0026rsquo;ve optimized your wasm to the end of the road, you might as well boldly try this solution. ðŸ˜†\nRemember in the \u0026ldquo;Network Level\u0026rdquo; section above, there was a question about whether manual compression is needed, well, here it\u0026rsquo;s manual compression and decompression all the way, haha.\nPhysical Compression First, perform physical gzip compression on the wasm file, here we\u0026rsquo;ll use the original wasm (23347b):\n1 gzip -c pkg/hello_wasm_bg.wasm \u0026gt; pkg/output.gz Then, look at its size:\n1 2 $ wc -c pkg/output.gz 10403 pkg/output.gz The effect is excellent, reduced from 23347b to 10403b!\nThen let\u0026rsquo;s go through the optimization of the above \u0026ldquo;Code Level\u0026rdquo; and see the final size:\n1 2 $ wc -c pkg/output.gz 9237 pkg/output.gz The effect is even more excellent, reduced from 19871b to 9237b!\nSo, here we physically compress and store the wasm file, and when the browser requests, it directly requests the .gz file.\nPhysical Decompression After the browser gets the .gz file, it needs to physically decompress it.\nHere we recommend using the frontend library pako to decompress the .gz file:\n1 2 3 4 5 6 7 8 9 async function gunzipWasm() { const res = await fetch(\u0026#34;target.gz\u0026#34;) let buffer = await pako.ungzip(await res.arrayBuffer()) // A fetched response might be decompressed twice on Firefox. // See https://bugzilla.mozilla.org/show_bug.cgi?id=610679 if (buffer[0] === 0x1F \u0026amp;\u0026amp; buffer[1] === 0x8B) {buffer = pako.ungzip(buffer)} return buffer } Then it can be used directly.\nBUFF Stacking Here we directly use all the above methods, stack the buffs directly, and see how much size we can reduce for this case (accumulated in this series of articles). In the \u0026ldquo;Physical Level\u0026rdquo; section, we\u0026rsquo;ve already accumulated the buffs except for the \u0026ldquo;Network Level\u0026rdquo;, so we can directly use its results. And in the \u0026ldquo;Network Level\u0026rdquo; section, using gzip for compression, we estimate the compression rate of gzip at 40%.\nThen the final wasm size of this case will be 5542b, with a compression rate of about 77%!\nOf course, we also need to calculate an initial language buff - Rust, using Rust itself has already caused the wasm file size to be very small.\nConclusion In this article, we introduced wasm file size optimization solutions from three levels: code level, network level, and physical level, with a total of four solutions.\nFinally, after stacking all the buffs, the current case (accumulated in this series of articles) can reduce the size by 77%, which really feels great, haha.\nHope this can be helpful to everyone.\n","date":"2023-10-27T00:00:00Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/post/getting-fancy-with-rust-and-webassembly-part-4-smaller-wasm-file-size/","title":"Getting Fancy with Rust and WebAssembly (Part 4) - Smaller wasm file size"},{"content":"Introduction In the previous article \u0026ldquo;Getting Fancy with Rust and WebAssembly (Part 2) - DOM Manipulation and Type Conversion\u0026rdquo;, we described how to use Rust to manipulate the DOM and implement various methods for type conversion between Rust and JS.\nWhen developing web applications, Wasm modules written in Rust can provide higher performance and better security. However, to integrate with existing JavaScript code, interaction between Rust and JS must be implemented. The main purpose of Rust-JS interaction is to combine the advantages of both languages to achieve better web applications.\nBased on the various methods of type conversion between Rust and JS in the previous article, this article continues to delve into the interaction between Rust and JS.\nFirst, the type conversion between Rust and JS can achieve variable passing, so where are these variables to be used? It must be in functions!\nTherefore, this article will discuss the mutual function calls between Rust and JS. Based on this, a large number of daily functional developments can be implemented.\nAdditionally, we will also discuss how to export Rust structs for JS to use.\nYes, that\u0026rsquo;s right, calling Rust structs in JS! When I first saw this feature, my mind was a bit blown\u0026hellip;\u0026hellip;ðŸ˜³\nIn this article, we will continue development based on the project created in the previous article.\nEnvironment Rust 1.70.0 wasm-bindgen 0.2.87 Mutual Function Calls JS Calling Rust Functions Actually, in the first article of this series, we used JS calling Rust functions as an example for demonstration. Here we\u0026rsquo;ll still use this as an example, mainly to discuss the key points.\nFirst, declare a Rust function:\n1 2 3 4 5 6 use wasm_bindgen::prelude::*; #[wasm_bindgen] pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } The key points to note here are as follows:\nImport wasm_bindgen Declare a function, use pub to declare Use the #[wasm_bindgen] macro on the function to export the Rust function as a function of the WebAssembly module Then, compile it into a wasm file:\n1 wasm-pack build --target web Next, call this function in JS:\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; Finally, start the http server, and you can see the result from rust is: 3 in the browser\u0026rsquo;s console, indicating a successful call!\nRust Calling JS Functions Specifying JS Objects When calling JS functions in Rust, you need to specify JS objects, which means you need to explicitly tell Rust where this JS function is taken from JS to use.\nIt mainly involves the following two ways:\njs_namespace: This is an optional attribute used to specify a JavaScript namespace that contains functions to be exported in the wasm module. If js_namespace is not specified, all exported functions will be placed in the global namespace. js_name: This is another optional attribute used to specify the function name in JavaScript. If js_name is not specified, the exported function name will be the same as the function name in Rust. JS Native Functions For some JS native functions, in Rust, you need to look for alternative solutions. For example, the console.log() function we talked about in the previous article, isn\u0026rsquo;t it a bit troublesome!\nSo, do you want to directly call JS native functions in Rust?!\nHere, let\u0026rsquo;s take the console.log() function as an example, directly import and call it in Rust, avoiding the trouble of alternative solutions.\nFirst, here\u0026rsquo;s the Rust code:\n1 2 3 4 5 6 7 8 9 10 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log(\u0026#34;hello, javascript!\u0026#34;); } In the above code, the call_js_func function, as the name suggests, calls the js function and passes the parameter hello, javascript!.\nSo, let\u0026rsquo;s analyze the code above the call_js_func function step by step:\nThe first line of code #[wasm_bindgen] is a Rust attribute that tells the compiler to export the function as a WebAssembly module extern \u0026quot;C\u0026quot; is the C language calling convention, which tells the Rust compiler to export the function as a C language function #[wasm_bindgen(js_namespace = console)] tells the compiler to bind the function to the console object in JavaScript fn log(message: \u0026amp;str) is a Rust function that takes a string parameter and prints it to the console object in JavaScript The key to interacting with JS here is js_namespace. In Rust, js_namespace is an attribute used to specify the JavaScript namespace. In WebAssembly, we can use it to bind functions to objects in JavaScript.\nIn the above code, #[wasm_bindgen(js_namespace = console)] tells the compiler to bind the function to the console object in JavaScript. This means that the log() function in Rust is called using the console.log() function in JS.\nTherefore, similar native functions can all be called using this method.\nFinally, let\u0026rsquo;s call it in JS:\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { call_js_func } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); call_js_func(); } run(); \u0026lt;/script\u0026gt; You can see hello, javascript! in the browser\u0026rsquo;s console. Wonderful!\nActually, for console.log(), there\u0026rsquo;s another way to call it, which is to use js_namespace and js_name together.\nYou might ask, is there any difference? Yes, there is some difference.\nI don\u0026rsquo;t know if you\u0026rsquo;ve noticed, in the current example, js_namespace is specified as console, but the actual executed function is log(). So the specification of this log function is actually reflected in the same function name log in Rust. In other words, the log() in this example is the log() in console.log().\nLet\u0026rsquo;s try changing the name, change the original log() to log2():\n1 2 3 4 5 6 7 8 9 10 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log2(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log2(\u0026#34;hello, javascript!\u0026#34;) } Then after compiling, look at the console, you\u0026rsquo;ll see an error:\n1 TypeError: console.log2 is not a function Therefore, when we use the combination of js_namespace and js_name, we can customize the function name here.\nLet\u0026rsquo;s look at the Rust code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log(message: \u0026amp;str); #[wasm_bindgen(js_namespace = console, js_name = log)] fn log_str(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log_str(\u0026#34;hello, javascript!\u0026#34;) } Here, a new function log_str is defined, but it specifies js_namespace = console and js_name = log, so here, a custom function name can be used.\nAfter directly compiling, look at the console, you can see the normal output: hello, javascript!.\nTo summarize, if js_name is not specified, the Rust function name will be used as the JS function name.\nCustom JS Functions In certain scenarios, you need to use Rust to call JS functions, such as scenarios that are more advantageous for JS - use JS to manipulate DOM, use Rust to calculate.\nFirst, create a file index.js, write a function:\n1 2 3 export function addIt(m, n) { return m + n; }; The current file structure relationship is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . â”œâ”€â”€ Cargo.lock â”œâ”€â”€ Cargo.toml â”œâ”€â”€ README.md â”œâ”€â”€ index.html â”œâ”€â”€ index.js â”œâ”€â”€ pkg â”‚Â â”œâ”€â”€ README.md â”‚Â â”œâ”€â”€ hello_wasm.d.ts â”‚Â â”œâ”€â”€ hello_wasm.js â”‚Â â”œâ”€â”€ hello_wasm_bg.wasm â”‚Â â”œâ”€â”€ hello_wasm_bg.wasm.d.ts â”‚Â â””â”€â”€ package.json â”œâ”€â”€ src â”‚Â â””â”€â”€ lib.rs â””â”€â”€ target â”œâ”€â”€ CACHEDIR.TAG â”œâ”€â”€ debug â”œâ”€â”€ release â””â”€â”€ wasm32-unknown-unknown Among them, index.js and lib.rs, as well as hello_wasm_bg.wasm are not at the same level, index.js is at the upper level of the other two files. Remember this structural relationship!\nThen, in lib.rs, specify the function:\n1 2 3 4 #[wasm_bindgen(raw_module = \u0026#34;../index.js\u0026#34;)] extern \u0026#34;C\u0026#34; { fn addIt(m: i32, n: i32) -\u0026gt; i32; } Where raw_module = \u0026quot;../index.js\u0026quot; means to specify the corresponding index.js file, you should be clear that this specifies the index.js we just created. The role of raw_module is to specify the js file.\nThis code in the frontend can be equivalent to:\n1 import { addIt } from \u0026#39;../index.js\u0026#39; This way, you don\u0026rsquo;t need to import it in the frontend, it\u0026rsquo;s directly imported in Rust, which feels a bit magical.\nNext, call this function in Rust:\n1 2 3 4 #[wasm_bindgen] pub fn call_js_func() -\u0026gt; i32 { addIt(1, 2) } Finally, call it in the frontend, after compiling, you can see the output result in the browser\u0026rsquo;s console!\nTo summarize, there are several points to note here:\nThe JS function must be exported, otherwise it cannot be called; raw_module can only be used to specify relative paths, and, as you can notice in the browser\u0026rsquo;s console, the ../ relative path here is actually the relative path in terms of the wasm file, this must be noted! JS Calling Rust\u0026rsquo;s struct Now, for something mind-blowing, JS calling Rust\u0026rsquo;s struct?!\nJS doesn\u0026rsquo;t even have structs, what will this exported thing look like, and how will it be called in JS?!\nFirst, define a struct, and declare several methods:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #[wasm_bindgen] pub struct User { name: String, age: u32 } #[wasm_bindgen] impl User { #[wasm_bindgen(constructor)] pub fn new(name: String, age: u32) -\u0026gt; User { User { name, age } } pub fn print_user(\u0026amp;self) { log(format!(\u0026#34;name is : {}, age is : {}\u0026#34;, self.name, self.age).as_str()); } pub fn set_age(\u0026amp;mut self, age: u32) { self.age = age; } } Here, a struct named User is declared, containing two fields name and age, and methods new, print_user, and set_age are declared.\nThere\u0026rsquo;s also an unseen #[wasm_bindgen(constructor)], constructor is used to indicate that the bound function should actually be converted to calling the new operator in JavaScript. You might not be very clear yet, but as you continue reading, you\u0026rsquo;ll understand.\nNext, call this struct and its methods in JS:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; function addIt2(m, n) { return m + n; }; import init, { User } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const user = new User(\u0026#39;HunterJi\u0026#39;, 20); user.set_age(21); user.print_user(); } run(); \u0026lt;/script\u0026gt; As you can see, the usage here is very familiar!\nThink about how to call it in Rust? That is, directly new one - User::new('HunterJi', 20).\nHere in JS, it\u0026rsquo;s the same, first new one!\nThen naturally call the struct\u0026rsquo;s methods.\nAfter compiling, open the browser, you can see the output in the console: name is : HunterJi, age is : 21.\nActually, you might be very curious, at least I was very curious, what exactly is Rust\u0026rsquo;s struct in JS?\nHere, directly add a console.log(user), and you can see in the output. So what exactly is it in JS? Please print it out and see for yourself! :P\nConclusion In this article, we mainly discussed the interaction between Rust and JS, reflected in the mutual calls between Rust and JS, which is based on the type conversion in the previous article.\nThe learning cost of mutual function calls between Rust and JS is still relatively high, and compared to writing wasm with Go, Rust\u0026rsquo;s granularity is very fine, almost can be said to be at will.\nThe most mind-blowing thing is exporting Rust\u0026rsquo;s struct for JS to use, which is a very great experience for the interaction between Rust and JS.\n","date":"2023-06-26T00:00:00Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/post/getting-fancy-with-rust-and-webassembly-part-3-rust-and-js-interaction/","title":"Getting Fancy with Rust and WebAssembly (Part 3) - Rust and JS interaction"},{"content":"Introduction In the previous article \u0026ldquo;Getting Fancy with Rust and WebAssembly (Part 1) - Quick Start\u0026rdquo;, we described how to create a project and quickly generate wasm for use in the frontend, taking the first step towards creating cool stuff.\nWhen developing web applications, Wasm modules written in Rust can provide higher performance and better security. However, to integrate with existing JavaScript code, interaction between Rust and JS must be implemented. The main purpose of Rust-JS interaction is to combine the strengths of both languages to achieve better web applications.\nIn this article, we will continue development based on the project created in the previous article.\nEnvironment Rust 1.70.0 wasm-bindgen 0.2.87 web-sys 0.3.64 DOM Configuring Dependencies To manipulate the DOM, we need to introduce a new dependency web-sys. Therefore, you can configure the dependencies in Cargo.toml as follows:\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [] } You might be curious about what this features is. To be honest, I was very curious at first and didn\u0026rsquo;t see any special explanation. I found out through trial and error that you need to manually import feature dependencies\u0026hellip; For example, if you need to use JS\u0026rsquo;s console in Rust, you need to add console to features.\nGetting the Document To use Document in Rust, we need to add features as explained in the previous step. There\u0026rsquo;s a dependency relationship here: first, we need to get the window in Rust, and then get the document.\nTherefore, after adding features, it looks like this:\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;] } Then create a function in lib.rs to call document:\n1 2 3 4 5 #[wasm_bindgen] pub fn update_message() { let window = web_sys::window().expect(\u0026#34;Failed to load window\u0026#34;); let document = window.document().expect(\u0026#34;Failed to load document\u0026#34;); } Now we have unlocked document in Rust, so we can do whatever we want in the frontend!\nManipulating Elements Let\u0026rsquo;s start manipulating. First, we need to get the Element\u0026hellip;\u0026hellip;\nYes, you guessed it right, let\u0026rsquo;s continue to add features. Here we need to add an Element:\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;] } OK, let\u0026rsquo;s continue. Here we set the function to take two parameters selector and message, then get the element through selector, and update the value to the value of the message parameter. The complete function is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 #[wasm_bindgen] pub fn update_message(selector: \u0026amp;str, message: \u0026amp;str) { let window = web_sys::window().expect(\u0026#34;Failed to load window\u0026#34;); let document = window.document().expect(\u0026#34;Failed to load document\u0026#34;); let element = document.query_selector(selector).expect(\u0026#34;Failed to load element\u0026#34;); if let Some(element) = element { element.set_inner_html(message); } else { panic!(\u0026#34;Failed to set inner html\u0026#34;) } } Compilation Compile the completed Rust project into wasm:\n1 wasm-pack build --target web Calling in HTML Based on the HTML from the project in the previous article, add a div here with id message, and add a call to the wasm update_message function. The code is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { update_message } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; // å¼•å…¥update_messageå‡½æ•° const run = async () =\u0026gt; { await init(); update_message(\u0026#39;#message\u0026#39;, \u0026#39;\u0026lt;h1\u0026gt;Hello, Rust!\u0026lt;/h1\u0026gt;\u0026#39;); // è°ƒç”¨update_messageå‡½æ•° } run(); \u0026lt;/script\u0026gt; Verification in Browser Start an HTTP server, then view it in the browser. You can see an h1 tag with Hello, Rust! appearing on the page.\nDiscovering More Methods As you write according to the article, you might notice a problem - why aren\u0026rsquo;t these methods auto-completing?!\nYes, that\u0026rsquo;s right, (at least I found that) currently web-sys doesn\u0026rsquo;t have auto-completion, so we can only develop by combining developers\u0026rsquo; excellent frontend skills and the rich official documentation.\nType Conversion Between Rust and JS For wasm, performance is certainly improved, but type conversion has always been an issue. When a large amount of data needs to be type-converted in wasm/js, it\u0026rsquo;s really a disaster for performance. I encountered this problem when developing wasm with Go before, where I needed to use official methods for manual type conversion, but wasm was dealing with a very large amount of data\u0026hellip;\u0026hellip;\nFortunately, Rust\u0026rsquo;s type support is really rich!\nBasic Types Basic types are quite simple, and Rust\u0026rsquo;s generics also support many types well. Here\u0026rsquo;s a mapping table of basic types:\nRustç±»åž‹ JavaScriptç±»åž‹ i8 number i16 number i32 number i64 BigInt u8 number u16 number u32 number u64 BigInt f32 number f64 number bool boolean char string \u0026amp;str string String string \u0026amp;[T] For exampleï¼š\u0026amp;[u8] [T] For exampleï¼šUint8Array Vec\u0026lt;T\u0026gt; Array Basic Type Conversion Example In the lib.rs file, create a function that takes a few types as parameters, then reads and prints them:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] pub fn print_values(js_number: i32, js_boolean: bool, js_uint8_array: \u0026amp;[u8], js_number_array: Vec\u0026lt;i32\u0026gt;) { println!(\u0026#34;js number: {}\u0026#34;, js_number); println!(\u0026#34;js boolean: {}\u0026#34;, js_boolean); for item in js_uint8_array { println!(\u0026#34;js Uint8Array item: {}\u0026#34;, item); } for item in js_number_array { println!(\u0026#34;js number array item: {}\u0026#34;, item); } } You can see that this function takes four types of parameters from JS: number, boolean, Uint8Array, and Array.\nThen compile:\n1 wasm-pack build --target web Next, import the function and call it in the frontend:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { print_values } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const jsNumber = 10; const jsBoolean = true; const jsUint8Array = new Uint8Array(3); jsUint8Array[0] = 1; jsUint8Array[1] = 2; jsUint8Array[2] = 3; const jsNumberArray = [30, 40, 50]; print_values(jsNumber, jsBoolean, jsUint8Array, jsNumberArray); } run(); \u0026lt;/script\u0026gt; Finally, start the HTTP server and open the browser, and in the console you can see\u0026hellip; you can\u0026rsquo;t see?!\nYes, that\u0026rsquo;s right, Rust\u0026rsquo;s println! will only send the printed content to Rust\u0026rsquo;s standard output stream, not the frontend\u0026rsquo;s console. If you want to print in the console, you need to call JS\u0026rsquo;s console.\nTo use the new functionality, the first step is to add features. Add console to Cargo.toml as follows:\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;console\u0026#34;] } Calling console.log() in Rust is as follows:\n1 web_sys::console::log_1(\u0026amp;\u0026#34;Hello, Rust!\u0026#34;.into()); Here we encapsulate it into a function:\n1 2 3 fn console_log(message: String) { web_sys::console::log_1(\u0026amp;message.into()); } Then, change the println in the example function to console_log() and format!. The function code is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] pub fn print_values(js_number: i32, js_boolean: bool, js_uint8_array: \u0026amp;[u8], js_number_array: Vec\u0026lt;i32\u0026gt;) { console_log(format!(\u0026#34;js number: {}\u0026#34;, js_number)); console_log(format!(\u0026#34;js boolean: {}\u0026#34;, js_boolean)); for item in js_uint8_array { console_log(format!(\u0026#34;js Uint8Array item: {}\u0026#34;, item)); } for item in js_number_array { console_log(format!(\u0026#34;js number array item: {}\u0026#34;, item)); } } Finally, after compiling, open the browser, and you can see the output in the console:\n1 2 3 4 5 6 7 8 js number: 10 js boolean: true js Uint8Array item: 1 js Uint8Array item: 2 js Uint8Array item: 3 js number array item: 30 js number array item: 40 js number array item: 50 Generic Type Rust provides a generic type - JsValue, which can be used as any JS type.\nHere\u0026rsquo;s a simple example, setting up a function that takes JsValue as a parameter and prints it.\nCreate the function:\n1 2 3 4 #[wasm_bindgen] pub fn print_js_value(val: JsValue) { console_log(format!(\u0026#34;{:?}\u0026#34;, val)); } Then compile it into a wasm file.\nCall it in HTML:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { print_js_value } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const jsNumber = 10; const jsBoolean = true; const jsUint8Array = new Uint8Array(3); jsUint8Array[0] = 1; jsUint8Array[1] = 2; jsUint8Array[2] = 3; const jsNumberArray = [30, 40, 50]; print_js_value(jsNumber); print_js_value(jsBoolean); print_js_value(jsUint8Array); print_js_value(jsNumberArray); } run(); \u0026lt;/script\u0026gt; In the HTML, different types of parameters are passed in, but in the browser\u0026rsquo;s console, you can see that all different types of parameters are printed:\n1 2 3 4 JsValue(10) JsValue(true) JsValue(Uint8Array) JsValue([30, 40, 50]) Result Result is a very important existence in Rust. If you often write Rust, you don\u0026rsquo;t want to change your development habits when writing WebAssembly.\nFor JS, Result can be directly caught in catch, but here we need to define the parameter types well.\nUsing Result to Return Errors First, let\u0026rsquo;s look at a scenario that only returns errors:\n1 2 3 4 5 6 7 8 #[wasm_bindgen] pub fn only_return_error_when_result(count: i32) -\u0026gt; Result\u0026lt;(), JsError\u0026gt; { if count \u0026gt; 10 { Ok(()) } else { Err(JsError::new(\u0026#34;count \u0026lt; 10\u0026#34;)) } } Here the return type is Result, but it only returns an error. It\u0026rsquo;s worth noting that the error type used here is JsError, of course, JsValue can also be used here.\nThen call it in HTML:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { only_return_error_when_result } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); try { only_return_error_when_result(1); console.log(\u0026#39;1 is ok\u0026#39;); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 1: \u0026#39;, error); } try { only_return_error_when_result(100); console.log(\u0026#39;100 is ok\u0026#39;); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 100: \u0026#39;, error); } } run(); \u0026lt;/script\u0026gt; Here it\u0026rsquo;s called twice, the first time should be an error, the second time should be correct, and both use catch to catch errors.\nSo, in the browser\u0026rsquo;s console, you can see the output:\n1 2 An error is reported when the input parameter is 1: Error: count \u0026lt; 10 100 is ok Using Result to Return Normal Values and Errors So, what if you want to return both normal values and errors? Rust returning a Result is no problem, but how does JS parse it?\nLet\u0026rsquo;s go straight to the Rust code:\n1 2 3 4 5 6 7 8 #[wasm_bindgen] pub fn return_all_when_result(count: i32) -\u0026gt; Result\u0026lt;i32, JsError\u0026gt; { if count \u0026gt; 10 { Ok(count + 10) } else { Err(JsError::new(\u0026#34;count \u0026lt; 10\u0026#34;)) } } This function, after getting the parameter, if it meets the condition, adds 10 and returns, otherwise it reports an error.\nLet\u0026rsquo;s see how to call it in HTML:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { return_all_when_result } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); try { const res = return_all_when_result(1); console.log(`get ${res}`); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 1: \u0026#39;, error); } try { const res = return_all_when_result(100); console.log(`get ${res}`); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 100: \u0026#39;, error); } } run(); \u0026lt;/script\u0026gt; Yes, that\u0026rsquo;s right, just get it normally\u0026hellip;.. /facepalm\nThe call here is still, the first one is wrong, the second one correctly returns a value, and both use catch to catch errors.\nFinally, in the browser\u0026rsquo;s console, you can see:\n1 2 An error is reported when the input parameter is 1: Error: count \u0026lt; 10 get 110 Directly Importing JS Types If you want to be more direct, you can directly import JS types! This mainly uses the js-sys dependency, you can see many JS types and functions on the official documentation, just import them directly to use. Of course, in certain scenarios, directly imported types need to be manually converted.\nConfiguring Dependencies Add the js-sys dependency in Cargo.toml:\n1 2 3 4 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;console\u0026#34;] } js-sys = \u0026#34;0.3.61\u0026#34; Uint8Array First, take Uint8Array as an example, import the type at the top of lib.rs:\n1 use js_sys::Uint8Array; Then create a function with parameters and return both of type Uint8Array:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #[wasm_bindgen] pub fn print_uint8_array(js_arr: Uint8Array) -\u0026gt; Uint8Array { // new Uint8Array let mut arr = Uint8Array::new_with_length(3); // Uint8Array -\u0026gt; vec for (index, item) in js_arr.to_vec().iter().enumerate() { console_log(format!(\u0026#34;{} - the item in js_arr: {}\u0026#34;, index, item)); } // Avoid type conversion // Use the method of the type itself for index in 0..js_arr.length() { console_log(format!(\u0026#34;{} - the item in js_arr: {}\u0026#34;, index, js_arr.get_index(index))); } // vec -\u0026gt; Uint8Array let vec = vec![1, 2, 3]; let arr2 = Uint8Array::from(vec.as_slice()); arr = arr2.clone(); // Use the method of the type itself arr.set_index(0, 100); arr } Ignore the meaningless logic in this function and the warning of the arr variable, it\u0026rsquo;s just for demonstration purposes.\nYou can see in the code that the directly imported Uint8Array has its own methods. In certain scenarios, type conversion is needed, but it\u0026rsquo;s best to avoid type conversion and directly use its own methods.\nWe can briefly summarize here that it\u0026rsquo;s best to use directly imported JS types entirely within certain scenarios, or use Rust types to replace JS types entirely. When both exist, manually converting types is a terrible thing.\nDate The Date type wasn\u0026rsquo;t mentioned in the above sections. Here we can directly import and use the JS Date type.\nFirst, import the type:\n1 use js_sys::Date; Then, create a function that returns a timestamp:\n1 2 3 4 5 #[wasm_bindgen] pub fn return_time() -\u0026gt; f64 { let date = Date::new_0(); date.get_time() } Then, call it in HTML:\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { return_time } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); console.log(\u0026#39;current time: \u0026#39;, return_time()); } run(); \u0026lt;/script\u0026gt; Finally, in the browser\u0026rsquo;s console, you can see:\n1 current time: 1686979932833 Conclusion In this article, we mainly discussed how to use Rust to implement DOM operations. Readers can find suitable methods to implement their own scenarios based on the methods. Secondly, we also discussed the type conversion between Rust and JS, from the mapping of basic types of each, to Rust\u0026rsquo;s unique Result, to directly importing JS types. Of course, it should be noted that directly importing JS types and mapping JS types to Rust\u0026rsquo;s basic types should not be mixed as much as possible. Mixing will lead to the need for manual type conversion, causing performance loss.\nAt this point, we\u0026rsquo;ve taken another step towards creating cool stuff with Rust and WebAssembly~ðŸ˜¼\n","date":"2023-06-14T00:00:00Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/post/getting-fancy-with-rust-and-webassembly-part-2-dom-manipulation-and-type-conversion/","title":"Getting Fancy with Rust and WebAssembly (Part 2) - DOM Manipulation and Type Conversion"},{"content":"Introduction WebAssembly is a new type of code that can be run in modern web browsers - it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++ with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.\nI previously wrote an article about how to develop WebAssembly using Golang - WebAssembly: An Essential Skill for Future Front-end Development.\nBoth Rust and Go can be used to develop WebAssembly, but they have their own advantages and disadvantages.\nRust\u0026rsquo;s advantages:\nFaster performance and smaller binary files Better memory safety Go\u0026rsquo;s advantages:\nEasier to get started and learn Better ecosystem and community support Overall, if you prioritize performance and memory safety, then Rust might be the better choice. If you value development efficiency and ease of use, then Go might be more suitable for you. Of course, the actual choice should be based on specific project requirements and team circumstances.\nDue to some work requirements, I\u0026rsquo;ve recently been working on some Rust projects, and I\u0026rsquo;d like to systematically document it here. I hope this can be helpful when you encounter scenarios that prioritize performance and memory safety.\nEnvironment Rust 1.70.0 wasm-bindgen 0.2.87 Create Project and Add Dependencies This assumes Rust is already installed. If you need to install it, please refer to the official website.\nUse Cargo to create a project named hello-wasm:\n1 cargo new --lib hello-wasm Enter the project, open the Cargo.toml file, and add dependencies:\n1 2 3 4 5 [lib] crate-type = [\u0026#34;cdylib\u0026#34;] [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; Update lib.rs In the default project creation, there\u0026rsquo;s a file named lib.rs. Replace all its content with:\n1 2 3 4 5 6 use wasm_bindgen::prelude::*; #[wasm_bindgen] pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } Compile At this point, we\u0026rsquo;ve created the simplest function - one that returns the sum of two integers.\nNow we can proceed with compilation. Before compiling, we need to install a tool called wasm-pack:\n1 cargo install wasm-pack Then compile:\n1 wasm-pack build --target web After compilation, a pkg folder will be created with the following content:\n1 2 3 4 5 6 pkg â”œâ”€â”€ hello_wasm.d.ts â”œâ”€â”€ hello_wasm.js â”œâ”€â”€ hello_wasm_bg.wasm â”œâ”€â”€ hello_wasm_bg.wasm.d.ts â””â”€â”€ package.json Although there are many files, we can see the wasm file we need, and based on Go\u0026rsquo;s wasm import method, we might need to use the js file here.\nFrontend Integration To quickly verify, let\u0026rsquo;s create an index.html file directly in the hello-wasm project for frontend integration.\nCreate index.html First, create an index.html file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Getting Fancy with Rust and WebAssembly\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello, World! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Yes, that\u0026rsquo;s right! This is a standard opening! ðŸ˜¼\nImport WASM Unlike Go\u0026rsquo;s wasm import method, Rust prefers to directly import the js file rather than having developers manually import the wasm file.\nHere we use js import:\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; Complete Code The complete HTML code is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Getting Fancy with Rust and WebAssembly\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello, World! \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Verification Here we can quickly start an http server. I choose to use http-server, but you can also use methods like python3 -m http.server, depending on your personal preferences.\nSo, start the http server:\n1 http-server Open your browser, visit http://localhost:8080, open the debugger, and you should see the output the result from rust is: 3, which means we\u0026rsquo;ve taken the first step in doing some fancy stuff!\nCommon Issues Frontend Reports Response Type Error The detailed error is as follows:\n1 Failed to load module script: The server responded with a non-JavaScript MIME type of \u0026#34;application/wasm\u0026#34;. Strict MIME type checking is enforced for module scripts per HTML spec. You might encounter this error when importing the js file generated by WebAssembly. At first glance, it seems to be an http server response issue, and when searching, you might find posts saying it\u0026rsquo;s a response problem.\nIn fact, when following this article step by step, you won\u0026rsquo;t encounter this problem because the compilation parameter in this article directly solves this issue. When I was figuring this out on my own, solving this problem really drove me crazy\u0026hellip;\nThe key lies in the --target parameter of the compilation command.\nWhen this parameter is not set, the default is actually --target bundler, which compiles for use with scaffolds like webpack. Therefore, using --target web here compiles it for direct use in the web.\nThe relevant parameters are as follows:\nbundler: Compile for use with scaffolds like webpack web: Compile for direct use in web nodejs: Compile into a node module that can be loaded via require deno: Compile into a deno module that can be loaded via import no-modules: Similar to web, but older and cannot use ES modules Directly Importing the WASM File If you try to directly import the wasm file instead of using the method described in this article, you\u0026rsquo;ll find that it works too!\n1 2 3 4 5 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; WebAssembly.instantiateStreaming(fetch(\u0026#34;./pkg/hello_wasm_bg.wasm\u0026#34;), {}).then( (obj) =\u0026gt; console.log(\u0026#39;the result from rust is: \u0026#39;, obj.instance.exports.add(1, 2)) ); \u0026lt;/script\u0026gt; Yes, that\u0026rsquo;s right, it works for now, but when you introduce other things like DOM manipulation, it starts to break\u0026hellip;\nUpdated WASM Import Method Regarding the previous issue, let\u0026rsquo;s not discuss whether we can directly import the wasm file. Here, I\u0026rsquo;ll just mention the instantiateStreaming method. This is an updated method that doesn\u0026rsquo;t require conversion to arrayBuffer, which I discovered while exploring Rust projects. If you\u0026rsquo;re importing wasm in other languages, please use this updated method.\n","date":"2023-06-13T00:00:00Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/post/getting-fancy-with-rust-and-webassembly-part-1-quick-start/","title":"Getting Fancy with Rust and WebAssembly (Part 1) - Quick Start"}]