[{"content":"前言 继上次跟大家分享 我的本地自动生成中文字幕的流程后，我将这个流程更加自动化了。\n之前的流程还有较多人工参与的环节。\n但是现在，我只要导出音频，一键执行，就能直接得到带样式的FCPXML文件了！\n我们一起来看看吧！\n实现效果 首先，我准备好导出的音频文件和稿子。\n然后，启动！\n可以看到，这中间经过了自动识别和生成中文字幕，利用本地的AI大模型结合我的稿子自动校验字幕，将校验后的srt字幕文件转成带样式的FCPXML字幕文件这几个步骤。\n这样一键执行后，我直接导入生成的 FCPXML 字幕文件就行了！轻轻松松！\n这里的 FCPXML 字幕文件的样式是我自己调的我喜欢的样式，然后在程序里使用，直接生成，导入字幕文件就可以用。\n仍需加强 不过，现在还不够自动化。\n每次录完视频，剪口播视频太麻烦了，所以我会继续完善这个自动化的工作流。\n我希望能从自动剪口播视频开始，直接得到一个剪辑后的口播视频，和FCPXML文件。\n我后续会将这套流程开发成一个App，免费分享给大家使用！最好是开箱即用。\n感兴趣的小伙伴儿可以关注我，一起来让工作效率起飞吧！\n小插曲 这里有一个小插曲。\n我上次分享流程的时候，有些小伙伴儿跟我提到需要将SRT转成FCPXML。\n我就想到，直接右键转换是不是会很方便。\n所以，我就在我的APP“文件夹夹”中，加入了这个功能。在srt字幕文件的右键菜单，加入了一键生成FCPXML文件的功能，目前用的是我自己用的这个样式。\n希望文件夹夹不仅能让你访问文件更加便捷，还能提供一些工具，让工作更高效！\n","date":"2024-12-26T00:00:00Z","image":"https://hunterji.com/zh-cn/post/%E6%90%9E%E5%AE%9A%E4%B8%80%E9%94%AE%E6%9C%AC%E5%9C%B0%E5%85%8D%E8%B4%B9%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%B8%AD%E6%96%87%E5%AD%97%E5%B9%95%E4%B8%8D%E4%BB%85%E8%87%AA%E5%8A%A8%E6%A0%A1%E9%AA%8C%E8%BF%98%E8%83%BD%E7%94%9F%E6%88%90fcpxml/cover_hu8025522501978336710.jpeg","permalink":"https://hunterji.com/zh-cn/post/%E6%90%9E%E5%AE%9A%E4%B8%80%E9%94%AE%E6%9C%AC%E5%9C%B0%E5%85%8D%E8%B4%B9%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%B8%AD%E6%96%87%E5%AD%97%E5%B9%95%E4%B8%8D%E4%BB%85%E8%87%AA%E5%8A%A8%E6%A0%A1%E9%AA%8C%E8%BF%98%E8%83%BD%E7%94%9F%E6%88%90fcpxml/","title":"搞定！一键本地免费自动生成中文字幕，不仅自动校验，还能生成FCPXML"},{"content":"天呐，又要给视频加字幕了\u0026hellip; 作为一个刚用 Final Cut Pro 的新手，我非常头疼的是：它居然不支持自动生成中文字幕！ 新出的字幕生成仅支持英文。剪映的生成字幕功能收费了。 手打字幕，要花掉大把时间。 难道没有更好的解决方案吗？\n探索过程 我开始疯狂搜索解决方案。 市面上确实有不少中文字幕生成工具，看起来都挺诱人的。 但仔细研究后，我却犹豫了： 有的软件功能要么太过庞大，大大超出了我的需求， 有的则需要一些额外的资源， 并且mac上安装有点麻烦，等等一些原因让我有点劝退，并不是特别符合我的需求。\n转折点 这些软件大都是用Whisper模型识别语音，有的还加入了AI校对和翻译功能。 既然明白了原理，为什么不基于自己现有的条件，搭建一个适合自己的工作流程呢？\n我的解决方案 经过尝试，我找到了最适合自己的工作流：\n先把视频中的背景音乐静音，只导出人声 直接下载 Whisper 模型，用它识别语音，生成初版字幕。这时候生成的字幕比较粗糙，会有一些错别字之类的。 找一个ai平台，让 AI 基于我写的稿子帮我校对，特别是那些专业术语。 这里也可以使用一些网页的免费ai平台。 将生成的字幕文件导入final cut pro，就可以轻松用上字幕了！ 不过，最好还是人工核对一下。 其实这套流程下来，基本人工的工作量就非常少了。比如我这个生成的字幕，这里只需要调整一下这句字幕的时间轴。 这样，我就可以轻松得到字幕啦～ 不仅省下了大把时间，字幕质量还很不错。\n一点小感悟 作为一个 Final Cut Pro 新手，我利用自己技术方面的强项来弥补我在剪辑方面的弱项，这让我不禁想尝试去打造一个属于自己的工作流程。 与其被体力活儿困扰，不如主动迭代工作方式，让效率起飞！\n还能更简单吗？ 这个方案还有较多人工参与的因素，怎么才能让它更加自动化呢？ 我会改进后给出我的方案。 如果你也在学习剪辑，或者对这个解决方案感兴趣，欢迎关注我。 让我们一起突破技能边界，打造自己的效率工作流吧！\n","date":"2024-12-12T00:00:00Z","image":"https://hunterji.com/zh-cn/post/final-cut-pro%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%87%E5%AD%97%E5%B9%95%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/cover_hu8025522501978336710.jpeg","permalink":"https://hunterji.com/zh-cn/post/final-cut-pro%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%87%E5%AD%97%E5%B9%95%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/","title":"Final Cut Pro如何实现中文字幕自动生成？"},{"content":"给Folder Slice重新设计了一个图标，自我感觉还不错，哈哈～ 😄\n","date":"2024-12-07T00:00:00Z","permalink":"https://hunterji.com/zh-cn/post/%E7%BB%99folder-slice%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%A0%87/","title":"给Folder Slice重新设计一个图标"},{"content":" Your browser does not support the video tag. ","date":"2024-12-05T00:00:00Z","image":"https://hunterji.com/zh-cn/post/%E6%90%9E%E6%80%AA%E8%AE%BE%E8%AE%A1%E5%B0%8F%E7%BB%83%E4%B9%A0-p/cover_hu13241738419993079047.png","permalink":"https://hunterji.com/zh-cn/post/%E6%90%9E%E6%80%AA%E8%AE%BE%E8%AE%A1%E5%B0%8F%E7%BB%83%E4%B9%A0-p/","title":"搞怪设计小练习 :P"},{"content":"前言 设想一个场景：\n你作为一个程序员，听着攒劲的小曲，写着优雅的代码，加班加点终于写完了迭代中分配的模块需求。然后你跟别的同事一联调，却发现各种问题。\n你跟同事A说：“你得在这种情况下给我数据A。“\n同事A一脸懵逼：“这种情况需求也没写啊，在这种情况下我也没有数据A啊！“\n然后你和同事A一起顺着业务流程，找到了负责上层模块的同事B。\n同事B一脸懵逼：“这个迭代中我没有这个模块的开发需求啊，这种情况下我也没有数据A啊！”\n然后你和同事A、同事B一起顺着业务流程，找到了负责上层模块的\u0026hellip;\u0026hellip;\n最后，你和同事ABC\u0026hellip;一起找到了产品，产品一脸懵逼：“那没办法，就改需求吧\u0026hellip;\u0026hellip;”\n你眼看着所剩无几的迭代时间，生无可恋地掏出手机，发个微信取消了这周末的相亲\u0026hellip;\n不知道程序员xdm有没有经历过这样的场景，如果各位程序员xd没有经历过这样的场景，那真的是恭喜你了，且行且珍惜！从毕业后参加工作开始，我是真的经历太多了，太痛了！\n我之后不断学习各种方法，尝试去破解这样的困局。虽然说，工作中的问题很多，但是能解决一个是一个，后面再慢慢跟各位分享其他问题中我的解决方案。\n所以，本篇文章将分享一波关于这类问题我的解决方案。谨代表个人主观观点。\n痛点 需求是用户的痛点，但是在这个场景下，是程序员的痛点\u0026hellip;\n那么，仔细分析一下，这个场景下的痛点，到底是什么呢？我认为是如下两点：\n产品给到的需求无法自洽，且场景覆盖不够 开发团队的技术评审和技术文档不到位 开发各自按照模块开发，忽略外部环境，仅仅当各自开发完成后联调时候才会组装应用，发现问题 当然，可能有程序员xd会疑问：这种问题不是靠严谨的开发流程就可以避免吗？\n理论上来说是这样的，但是以我个人经历而言，不管是大团队还是小团队，总有很多不稳定的因素，比如说迭代周期、协作流程的规范性等等。\n特别是在创业团队，或者有些项目特别着急的时候，经常是没有足够的时间给到团队的各个角色去充分准备的，甚至为了赶时间，会精简一些环节甚至直接去掉。这种时候出现这种问题导致改需求，往往是非常可怕的，后果也往往是开发团队加班。\n解决方案 我目前发现且实践后效果较好的方案，就是“曳光弹式开发”。\n什么是曳光弹 经常关注军事的小伙伴儿，应该了解，曳光弹是一种运用于军事场景的特殊子弹。\n我们都知道武器发射时需要瞄准，比如枪就通过照门和准星来瞄准，而坦克和装甲车以及飞机都有专用的瞄准具，非常复杂。对于轻武器来说，一般攻击距离都比较近，使用自带的机械瞄准具或者外加的光学瞄准镜都足够，但是在距离稍远的时候瞄准镜显然不够。而对于飞机和战斗机来讲，在空中飞行时飞行姿态变化多样，有时候进攻的时间很短，需要快速射击并且调整弹道，这时候就需要可以发光的曳光弹。\n曳光弹正如其名，可以发光而且指示弹道。曳光弹的结构比一般子弹更加复杂。子弹的弹壳部分和一般子弹一样，前半部分是钢心或者铅心的弹头，但是在后部有一个空腔，一般称作曳光管，里面填充着曳光剂。曳光剂的成分还比较复杂，一般来说主要成分是镁粉和铝镁合金粉，用来燃烧，除此之外还有硝酸锶。这样一来，燃烧的时候硝酸锶就会发出红光。大家平时看到的很多曳光弹还有黄光和绿光，加入钠盐就会发出黄光，而加入铜盐就会发出绿光。除此之外还在表面加入一层过氧化钡，以保证曳光剂被点燃。\n对于机枪手来说，如果射击距离较远，自然不能选择过于精确的设计方式，也就是说不能靠瞄准具来射击。而一般的机枪主要起压制和面杀伤作用，加入曳光弹就是机枪手更加快速方便的控制弹道，随时变化攻击的方向。如果没有曳光弹的话，射手根本无法发现自己的子弹弹道，也就很难去调整弹道。毕竟枪械射击温度升高之后，弹道会有所变化，不同的弹药不同的枪管也都会改变子弹的弹道，如果仅仅依靠枪械自身的瞄准具去调整反而会适得其反，而曳光弹就很好的解决了这个问题。\n在开发中的作用 理解曳光弹本身在军事中的作用后，我们再来看曳光弹式开发如何在开发中起作用。\n开发团队在接手到产品给到的业务需求后，特别是构建一些以前从未做过的东西时，对这个产品/功能的最终成效是模糊的。\n程序员就像坦克上的机枪手一样，在尝试在黑暗中击中目标。但是如果像文章一开始的时候，大家先埋头写自己的模块，然后再联调，最终发现问题，感觉就像一上战场，大家都朝着各自理解的方向拼命清空弹夹，击中目标的寥寥无几，最后受伤的还是自己。\n所以，此时，就需要先使用几颗曳光弹，去击中目标，在黑暗中划出轨迹，开发团队再调整方向，对着目标集中火力。\n如何应用 非常简单！步骤如下：\n找出级别最高的需求 以完成最基础的完整功能为目标，从前端到部署，开发一个可以运行的骨架 最后上相关需求的测试案例 这样，射出一颗曳光弹，穿透客户端、后端、数据库、运维、测试等不同层面。一旦击中目标——即符合用户需求，后续的任务便大都是搬砖的活儿，去丰富这个骨架。\n曳光弹并不是总能击中目标的，中途若是发现未能击中目标，便可在前期以极小成本去调整曳光弹的方向，继续发射曳光弹。\n如果你要问，什么是“最基础的完整功能”，那么可以这么说，那么举个例子：前端不要任何样式，直接能够满足比如表单功能即可，后端不用任何校验，能够处理和传递数据即可。\n总结 为了解决文章开头的问题，需要使用曳光弹式开发，先开发一个骨架，确认满足需求后，即可继续丰富骨架，完成产品。\n作为团队的一员，团队的每一个角色都很重要，程序员跟产品也是需要紧密协作，互帮互助，才能使得产品更好，也使得业绩更好。\n","date":"2023-12-05T15:56:29Z","image":"https://hunterji.com/zh-cn/post/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%AA%8C%E8%AF%81%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82/cover_hu3359176830913878668.png","permalink":"https://hunterji.com/zh-cn/post/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%AA%8C%E8%AF%81%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82/","title":"程序员如何快速验证业务需求?"},{"content":"前言 在上一篇文章《使用Rust和WebAssembly整花活儿(三)——Rust与JS交互》中，讲述了Rust与JS的交互，包括Rust与JS的函数相互调用，比较炸裂的功能就是使用JS调用Rust的struct，JS本身连struct都没有，居然可以调用Rust的struct，这对于Rust开发者的开发体验而言，是真的很棒！\n基于前面的系列文章，已经足以使用Rust开发一个完整的功能了。\n但是，在前端引入wasm文件时，还是可能存在一些问题，比如wasm文件较大，导致网页访问时间较长，用户体验较差。本篇文章将会通过多种途径来减少Rust编译wasm文件的体积，以减少前端加载wasm文件的时间。\n曾经一段时间，我一直用Go开发WebAssembly，其编译后的wasm文件体积还是较大的，为了减少wasm文件的体积真是煞费苦心，1xMB大小的wasm文件真的是太痛了\u0026hellip;\u0026hellip;但是体积优化往往都会指向一条“充满魅惑的不归路”——换成Rust开发😆！如果你已经在用Rust开发WebAssembly了，那么恭喜你，对Go而言，在wasm体积上，你已经赢在起跑线上了。\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 查看体积 在真正去减少体积前，我们需要来先看一下，当前情况下体积是多少，方便后续对比前后体积。\n查看体积的方式有多种，这里推荐几个，（Linux和MacOS）使用其一即可。\nls 可以使用ls -l或者ll：\n1 2 $ ll pkg/hello_wasm_bg.wasm -rw-r--r-- 1 kuari staff 23K Jul 20 21:52 pkg/hello_wasm_bg.wasm stat 1 2 $ stat pkg/hello_wasm_bg.wasm 16777222 142141572 -rw-r--r-- 1 kuari staff 0 23347 \u0026#34;Jul 20 21:52:53 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; \u0026#34;Jul 20 21:52:01 2023\u0026#34; 4096 48 0 pkg/hello_wasm_bg.wasm wc 1 2 $ wc -c pkg/hello_wasm_bg.wasm 23347 pkg/hello_wasm_bg.wasm 以wc为例，当前该wasm文件体积为23347b。\n代码层面 Link-Time Optimization (LTO) 是指在程序链接时进行的一种过程间优化（interprocedural optimization）。它允许编译器在链接阶段对多个编译单元进行优化，从而提高程序的性能、可靠性和安全性。\n从代码层面优化，主要是利用LTO（Link-Time Optimization）。\n代码内 在Cargo.toml中开启LTO：\n1 2 [profile.release] lto = true 开启LTO虽然能够减少编译后的体积，但是也会增加编译时间。\nLTO开启后，默认是在减少一定程度的编译体积的情况下，要确保编译的时间。如果你的需求就是更小的体积，而不是较短的时间，那么，可以通过手动指定编译等级来让LTO作出改变。\n在代码内可以使用如下等级：\ns：默认的 LTO 等级。它会进行最基本的 LTO 优化，包括内联函数、函数重写、数据重排等 z：最高级的 LTO 等级。它会进行更复杂的 LTO 优化，包括死代码消除、内存分配优化、安全性优化等 那么可以在Cargo.toml中这么配置：\n1 2 3 [profile.release] lto = true opt-level = \u0026#39;z\u0026#39; 原始的文件体积是23347b，现在编译后看一下体积：\n1 2 $ wc -c pkg/hello_wasm_bg.wasm 19879 pkg/hello_wasm_bg.wasm 很明显是减少体积！但是，使用z等级并不代表一定每次体积都会比s小的，有时候s也会比z小，这需要视代码情况而定。\n代码外 在代码外，可以使用wasm-opt来进行优化，其可以对 WebAssembly 模块进行多方面的优化，当然本篇文章中重点在体积方面（挖个坑，后面再详聊/狗头）。并且wasm-opt可以对所有符合WebAssembly规范的wasm文件进行优化，所以，就算你不是Rust写的，那也可以用其进行优化。（想想我曾经Go写的wasm，也是有多一个法子可以优化一把了\u0026hellip;\u0026hellip;）\n首先，来看一下wasm-opt的基本优化参数：\n-o：指定优化后的模块输出文件 -O：启用默认优化，等同于-Os参数 -O0：不进行任何优化 -O1：进行一些基本的优化，例如内联函数优化和死代码消除优化 -O2：进行更为彻底的优化，例如函数重写、数据重排、内存分配优化等 -O3：进行最为彻底的优化，包括一些可能影响程序功能的优化 -O4：与 -O3 相同，但会启用更为激进的优化 -Os：优化目标是减小代码大小，会进行一些可能影响性能的优化 -Oz：与 -Os 相同，但会启用更为激进的优化 基于本篇文章主题，此处将使用-Os和-Oz两种参数，其于上述\u0026quot;代码内\u0026quot;的等级是对应的。\n此处以原始wasm文件，以-Oz参数来执行一下，看一下对比效果：\n1 2 $ wc -c pkg/output.wasm 23194 pkg/output.wasm 再以上述开启“代码内“LTO编译后的wasm文件，以wasm-opt执行一下，看一下对比效果：\n1 2 $ wc -c pkg/output.wasm 19871 pkg/output.wasm 总体而言，wasm文件的体积越来越小。只是当前我这里的案例，是沿用系列文章内容的代码，没有什么实际性复杂代码，再者本身体积已经很小了，所以不会特别有效果。\n网络层面 网络层面的话，就是众所周知的在网络传输时，客户端和服务端约定相同的压缩算法，然后服务端给出时进行压缩，客户端接收时进行解压。网络层面可以对传输报文进行压缩，但不丢失信息。\n比如大家都很熟悉的gzip压缩算法，不过，压缩算法有好几种：\ngzip compress deflate br 其中gzip也是压缩率最高的了，此处就以gzip为例。\n在网络层面，将wasm文件以gzip压缩，减少其在传输时的体积。虽然减少了传输时的体积，但是浏览器在拿到压缩后的数据，需要消耗一定性能来解密。\n开启GZIP 开启GZIP其实简单，只要前后端约定好都用gzip就行了。\n首先，前端请求wasm文件时，需要在request header中放入浏览器支持的压缩模式：\n1 Accept-Encoding: gzip, deflate 接着，服务端收到这个请求后就可以给出服务端也支持的压缩模式，并告诉浏览器服务端将会用什么压缩模式。\n跟浏览器通信的方式就是将信息塞到respone header里面：\n1 Content-Encoding: gzip 这样就开启GZIP了。\n然后，就是浏览器接收到response的body和header，知道后端使用gzip压缩的，那么浏览器就会自动用gzip来解压，拿到完整的数据了。\n服务端支持 或许你会想问，浏览器能自动解密，那服务端怎么自动加密呢？要后端写代码让文件加密吗？\n那当然不是了，直接让http server来完成这个操作。此处以耳熟能详的Nginx为例。\n最简单的就是一行配置开启gzip了：\n1 gzip on; 也可以指定gzip的一些参数，比如可以加密的类型、最小加密长度等等：\n1 2 3 4 5 gzip on; gzip_types text/plain application/xml; gzip_proxied no-cache no-store private expired auth; gzip_min_length 1000; ... 更多的http server配置，可以去各自官方文档查阅。\n物理层面 你可能会惊奇，什么物理层面？！\n没错，真就是物理层面——直接对wasm文件进行gzip物理压缩！哈哈，这个方法也真是绝了，我之前在Go开发wasm时，寻找减少体积的时候发现的，如果你的wasm已经优化得穷途末路了，不妨大胆试试这个方案。😆\n还记得上面章节“网络层面“中，有个问题就是是否需要手动压缩，那么这里就是全程手动压缩和解压缩了，哈哈。\n物理压缩 首先，是对wasm文件进行物理层面的gzip压缩，此处先使用原始的wasm（23347b）：\n1 gzip -c pkg/hello_wasm_bg.wasm \u0026gt; pkg/output.gz 然后，看一下其体积：\n1 2 $ wc -c pkg/output.gz 10403 pkg/output.gz 效果卓群，从23347b减少到了10403b！\n然后来把上述“代码层面”的优化来一遍，看一下最后的体积：\n1 2 $ wc -c pkg/output.gz 9237 pkg/output.gz 效果更加卓群了，从19871b减少到了9237b了！\n所以，此处就是对wasm文件进行物理压缩并存储，然后浏览器请求时，直接请求到.gz文件。\n物理解压 浏览器拿到.gz文件后，需要物理解压。\n这里推荐使用pako这个前端库，对.gz文件进行解压：\n1 2 3 4 5 6 7 8 9 async function gunzipWasm() { const res = await fetch(\u0026#34;target.gz\u0026#34;) let buffer = await pako.ungzip(await res.arrayBuffer()) // A fetched response might be decompressed twice on Firefox. // See https://bugzilla.mozilla.org/show_bug.cgi?id=610679 if (buffer[0] === 0x1F \u0026amp;\u0026amp; buffer[1] === 0x8B) {buffer = pako.ungzip(buffer)} return buffer } 之后就可以直接使用了。\nBUFF叠加 此处直接将上述所有方法都用起来，直接叠加buff，来看看当前（本系列文章积累的）这个案例能减少多少体积。在“物理层面”章节中，已经累加除了“网络层面”的buff了，所以可以直接使用其结果。而“网络层面”章节中，以gzip来压缩，将gzip的压缩率以40%来估算。\n那么最终该案例的wasm体积将在5542b，压缩率大约在77%！\n当然，还要算上一个初始的语言buff——Rust，使用Rust本身就已经导致wasm文件体积很小了。\n总结 本片文章中，从代码层面、网络层面、物理层面共三个层面介绍了对wasm文件的体积优化方案，其中共有四个方案。\n最后，当前（本系列文章积累的）该案例叠加了所有buff之后，能够减少77%的体积，真的感觉挺棒的了，哈哈。\n希望能够对各位有所帮助。\n","date":"2023-10-26T23:51:13Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/zh-cn/post/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E5%9B%9B%E6%9B%B4%E5%B0%8F%E6%9B%B4%E5%B0%8F%E7%9A%84wasm%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF/","title":"使用Rust和WebAssembly整花活儿(四)——更小更小的wasm文件体积"},{"content":"前言 在上一篇文章《使用Rust和WebAssembly整花活儿(二)——DOM和类型转换》中，描述了使用Rust操作DOM，并实现Rust与JS类型转换的多种方法。\n在开发 Web 应用程序时，使用 Rust 编写的 Wasm 模块可以提供更高的性能和更好的安全性。但是，为了与现有的 JavaScript 代码集成，必须实现 Rust 与 JS 之间的交互。Rust 与 JS 交互的主要目的是将两种语言的优势结合起来，以实现更好的 Web 应用程序。\n基于上一篇文章中，Rust与JS的类型转换的多种方法，本篇文章继续深入Rust与JS的交互。\n首先，Rust与JS的类型转换，可以实现变量的传递，那么变量是要用在哪里呢？那必然是函数了！\n所以，本篇文章来讲述一下Rust与JS的函数相互调用，基于此，可以实现大量日常功能开发。\n并且，还将会讲述一下，如何导出Rust的struct给JS调用。\n是的，没错，在JS调用Rust的struct！一开始看到这个功能的时候，我的脑子是有点炸裂的\u0026hellip;\u0026hellip;😳\n本篇文章中，将基于上一篇文章中创建的项目来继续开发。\n源码：github.com/Kuari/hello-wasm\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 函数的相互调用 JS调用Rust函数 其实，在本系列文章的第一篇中，就是使用的JS调用Rust函数作为案例来演示的，这里依然以此为例，主要讲一下要点。\n首先，声明一个Rust函数：\n1 2 3 4 5 6 use wasm_bindgen::prelude::*; #[wasm_bindgen] pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } 此处需要注意的要点如下：\n引入wasm_bindgen 声明一个函数，使用pub声明 在函数上使用#[wasm_bindgen]宏来将Rust函数导出为WebAssembly模块的函数 接着，编译成wasm文件：\n1 wasm-pack build --target web 然后，在JS中调用该函数：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; 最后，启动http server，在浏览器的控制台中可以看到the result from rust is: 3，表明调用成功！\nRust调用JS函数 ###1 指定JS对象\n在Rust中调用JS函数，需要进行指定JS对象，也就是说，得明确告诉Rust，这个JS函数是从JS哪儿拿来的用的。\n主要在于下面两个方式：\njs_namespace: 是一个可选的属性，用于指定一个JavaScript命名空间，其中包含将要在wasm模块中导出的函数。如果没有指定js_namespace，则所有的导出函数将被放置在全局命名空间下。 js_name: 是另一个可选属性，它用于指定JavaScript中的函数名称。如果没有指定js_name，则导出函数的名称将与Rust中的函数名称相同。 ###2 JS原生函数\n对于一些JS原生函数，在Rust中，需要去寻找替代方案，比如我们上一篇文章中讲的console.log()函数，是不是觉得好麻烦啊！\n那么，你想直接在Rust中调用JS原生函数吗？！\n此处，就以console.log()函数为例，直接在Rust中引入并调用，免去替代方案的烦恼。\n首先，给出Rust代码：\n1 2 3 4 5 6 7 8 9 10 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log(\u0026#34;hello, javascript!\u0026#34;); } 如上代码中，call_js_func函数，顾名思义，此处是调用了js函数，并传入参数hello, javascript!。\n那么，call_js_func函数上方的代码，我们来一步步解析一下：\n第一行代码#[wasm_bindgen]是Rust的属性，它告诉编译器将函数导出为WebAssembly模块 extern \u0026quot;C\u0026quot;是C语言调用约定，它告诉Rust编译器将函数导出为C语言函数 #[wasm_bindgen(js_namespace = console)]告诉编译器将函数绑定到JavaScript中的console对象 fn log(message: \u0026amp;str)是一个Rust函数，它接受一个字符串参数，并将其打印到JavaScript中的console对象中 此处与JS交互的关键是js_namespace。在Rust中，js_namespace是用于指定JavaScript命名空间的属性。在WebAssembly中，我们可以通过它将函数绑定到JavaScript中的对象上。\n在上述代码中，#[wasm_bindgen(js_namespace = console)]告诉编译器将函数绑定到JavaScript中的console对象。这意味着在JS中使用console.log()函数来调用Rust中的log()函数。\n因此，类似的原生函数，都可以使用该方法来实现调用。\n最后，我们在JS中调用下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { call_js_func } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); call_js_func(); } run(); \u0026lt;/script\u0026gt; 可以在浏览器的控制台中看到hello, javascript!。妙啊！\n其实对于console.log()而言，还有另一种调用方式，那就是使用js_namespace和js_name同时指定。\n或许，你会问，这有什么不同吗？是的，这有些不同。\n不知道你是否发现，当前这个案例中，指定了js_namespace为console，但是真实执行的函数是log()，那么这个log函数的指定，其实是体现在Rust中同样的函数名log。也就是说，该案例的log()就是console.log()中的log()。\n我们来换个名字看看，将原来的log()换成log2()：\n1 2 3 4 5 6 7 8 9 10 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log2(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log2(\u0026#34;hello, javascript!\u0026#34;) } 然后编译后去控制台看看，就会看到报错：\n1 TypeError: console.log2 is not a function 因此，当我们使用js_namespace和js_name结合的方式，在此处是可以进行自定义函数名的。\n看一下Rust代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] extern \u0026#34;C\u0026#34; { #[wasm_bindgen(js_namespace = console)] fn log(message: \u0026amp;str); #[wasm_bindgen(js_namespace = console, js_name = log)] fn log_str(message: \u0026amp;str); } #[wasm_bindgen] pub fn call_js_func() { log_str(\u0026#34;hello, javascript!\u0026#34;) } 此处，重新定义了一个函数log_str，但是其指定了js_namespace = console和js_name = log，那么此处，就可以使用自定义的函数名。\n直接编译后，在控制台看一下，可以直接看到正常输出：hello, javascript!。\n总结一下，如果没有指定js_name，则 Rust 函数名称将用作 JS 函数名称。\n###3 自定义JS函数\n在一定场景下，需要使用Rust调用JS函数，比如对于一些对于JS而言更有优势的场景——用JS操作DOM，用Rust计算。\n首先，创建一个文件index.js，写入一个函数：\n1 2 3 export function addIt(m, n) { return m + n; }; 当前的文件结构关系如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . ├── Cargo.lock ├── Cargo.toml ├── README.md ├── index.html ├── index.js ├── pkg │ ├── README.md │ ├── hello_wasm.d.ts │ ├── hello_wasm.js │ ├── hello_wasm_bg.wasm │ ├── hello_wasm_bg.wasm.d.ts │ └── package.json ├── src │ └── lib.rs └── target ├── CACHEDIR.TAG ├── debug ├── release └── wasm32-unknown-unknown 其中，index.js和lib.rs，以及hello_wasm_bg.wasm都是不在同一级别的，index.js都在其它两个文件的上一级。记住这个机构关系！\n然后，在lib.rs中，指定函数：\n1 2 3 4 ##./index.js\u0026#34;)] extern \u0026#34;C\u0026#34; { fn addIt(m: i32, n: i32) -\u0026gt; i32; } 其中，raw_module = \u0026quot;../index.js\u0026quot;的意思是，指定对应的index.js文件，大家应该清楚，此处指定的是刚刚创建的index.js。raw_module的作用就是用来指定js文件的。\n这段代码在前端，可以等同于：\n1 import { addIt } from \u0026#39;../index.js\u0026#39; 这样在前端都不用引入了，直接在Rust中引入了，感觉还有点奇妙的。\n接着，在Rust调用该函数：\n1 2 3 4 #[wasm_bindgen] pub fn call_js_func() -\u0026gt; i32 { addIt(1, 2) } 最后，在前端调用，编译后，在浏览器的控制台中可以看到输出结果了！\n总结一下，这里有几个注意点：\nJS的函数必须要export，否则将无法调用； raw_module只能用来指定相对路径，并且，大家可以在浏览器的控制台中注意到，此处的../的相对路径，其实是以wasm文件而言的相对路径，这里一定要注意呀！ JS调用Rust的struct 现在，来点炸裂的，JS调用Rust的struct？！\nJS中连struct都没有，这玩意儿导出来会是什么样，得怎么在JS中调用呢？！\n首先，定义一个struct，并且声明几个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #[wasm_bindgen] pub struct User { name: String, age: u32 } #[wasm_bindgen] impl User { #[wasm_bindgen(constructor)] pub fn new(name: String, age: u32) -\u0026gt; User { User { name, age } } pub fn print_user(\u0026amp;self) { log(format!(\u0026#34;name is : {}, age is : {}\u0026#34;, self.name, self.age).as_str()); } pub fn set_age(\u0026amp;mut self, age: u32) { self.age = age; } } 此处，声明了一个struct名为User，包含name和age两个字段，并声明了new、print_user和set_age方法。\n其中还有一个未见过的#[wasm_bindgen(constructor)]，constructor用于指示被绑定的函数实际上应该转换为调用 JavaScript 中的 new 运算符。或许你还不太清晰，继续看下去，你就会明白了。\n接着，在JS中调用这个struct，和其方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; function addIt2(m, n) { return m + n; }; import init, { User } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const user = new User(\u0026#39;kuari\u0026#39;, 20); user.set_age(21); user.print_user(); } run(); \u0026lt;/script\u0026gt; 可以看到，这里的用法就很熟悉了！\n大概想一下，在Rust中要如何调用？也就是直接new一个——User::new('kuari', 20)。\n此处在JS中，也是如此，先new一个！\n然后很自然地调用struct的方法。\n编译后，打开浏览器，可以在控制台看到输出：name is : kuari, age is : 21。\n其实，或许大家会很好奇，起码我是非常好奇的，Rust的struct在JS中到底是一个怎样的存在呢？\n这里直接添加一个console.log(user)，就可以在输出看到。那么到底在JS中是一个怎样的存在呢？请各位动手打印一下看看吧！:P\n总结 本篇文章中，主要讲述了Rust与JS的交互，体现在Rust与JS的相互调用，这是建立在上一篇文章中类型转换的基础上的。\nRust与JS的函数相互调用的学习成本还是较大的，而且对比Go写wasm，Rust的颗粒度是非常细的，几乎可以说是随心所欲了。\n比较炸裂的就是Rust的struct导出给JS用，这对于Rust与JS的交互而言，还是非常棒的体验。\n","date":"2023-06-27T00:11:12Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/zh-cn/post/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%B8%89rust%E4%B8%8Ejs%E4%BA%A4%E4%BA%92/","title":"使用Rust和WebAssembly整花活儿(三)——Rust与JS交互"},{"content":"前言 在上一篇文章《使用Rust和WebAssembly整花活儿(一)——快速开始》中，描述了如何创建项目和快速生成wasm并在前端中使用，迈出了整花活儿的第一步。\n在开发 Web 应用程序时，使用 Rust 编写的 Wasm 模块可以提供更高的性能和更好的安全性。但是，为了与现有的 JavaScript 代码集成，必须实现 Rust 与 JS 之间的交互。Rust 与 JS 交互的主要目的是将两种语言的优势结合起来，以实现更好的 Web 应用程序。\n本篇文章中，将基于上一篇文章中创建的项目来继续开发。\n源码：github.com/Kuari/hello-wasm\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 web-sys 0.3.64 DOM 配置依赖 要操作DOM，需要引入新的依赖web-sys，因此，可以配置Cargo.toml中依赖如下：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [] } 你或许会好奇，这个features是什么，讲真，我一开始很好奇，又没看到什么特别的说明，试错才发现，原来是要手动引入功能依赖\u0026hellip;比如说，当你需要在Rust中使用JS的console，那么你需要在features中加入console。\n获取Document 在Rust中使用Document，我们需要按照上一步的说明，添加features。那么这里有一个依赖关系，首先在Rust中获取window，然后再获取document。\n因此，添加features后如下：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;] } 然后在lib.rs中创建一个函数，用来调用document：\n1 2 3 4 5 #[wasm_bindgen] pub fn update_message() { let window = web_sys::window().expect(\u0026#34;Failed to load window\u0026#34;); let document = window.document().expect(\u0026#34;Failed to load document\u0026#34;); } 那么，现在就是在Rust中解锁了document，就可以在前端为所欲为了！\n操作Element 那么开始操作一波，首先得获取到Element\u0026hellip;\u0026hellip;\n是的，你没有想错，继续来添加features吧，此处要添加一个Element：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;] } ok，那么继续。此处设定函数传入两个参数selector和message，然后通过selector获取element，更新值为message参数的值。完整函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 #[wasm_bindgen] pub fn update_message(selector: \u0026amp;str, message: \u0026amp;str) { let window = web_sys::window().expect(\u0026#34;Failed to load window\u0026#34;); let document = window.document().expect(\u0026#34;Failed to load document\u0026#34;); let element = document.query_selector(selector).expect(\u0026#34;Failed to load element\u0026#34;); if let Some(element) = element { element.set_inner_html(message); } else { panic!(\u0026#34;Failed to set inner html\u0026#34;) } } 编译 将写完的Rust项目编译成wasm：\n1 wasm-pack build --target web 在html中调用 基于上一篇文章的项目中的html，此处添加一个div，id为message，添加调用wasm的update_message函数，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { update_message } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; // 引入update_message函数 const run = async () =\u0026gt; { await init(); update_message(\u0026#39;#message\u0026#39;, \u0026#39;\u0026lt;h1\u0026gt;Hello, Rust!\u0026lt;/h1\u0026gt;\u0026#39;); // 调用update_message函数 } run(); \u0026lt;/script\u0026gt; 在浏览器验证 启动一个http server，然后在浏览器查看，可以看到在页面上出现一个h1标签的Hello, Rust!。\n发现更多方法 按照文章来写的过程中，你应该会发现一个问题——怎么这些方法没有补全？！\n是的，没错的，（至少我发现）当前web-sys并没有补全，所以只能结合开发者优秀的前端技能和丰富的官方文档来开发了。\nRust与JS的类型相互转换 对于wasm而言，性能固然是提升的，但是类型转换一直是个问题。当大量数据需要在wasm/js中进行类型转换时，这对性能来说，真的是个灾难。之前在使用go开发wasm时，就遇到过这样的问题，需要用官方的方法来进行手动类型转换，然而wasm处理的是一个很大的数据量\u0026hellip;\u0026hellip;\n不过好在Rust的类型支持真的挺丰富的！\n基础类型 基础类型挺简单的，而且Rust的范性也很好地支持了很多类型。如下是基础类型映射表：\nRust类型 JavaScript类型 i8 number i16 number i32 number i64 BigInt u8 number u16 number u32 number u64 BigInt f32 number f64 number bool boolean char string \u0026amp;str string String string \u0026amp;[T] 例如：\u0026amp;[u8] [T] 例如：Uint8Array Vec\u0026lt;T\u0026gt; Array 基础类型转换示例 在lib.rs文件中，创建一个函数，挑选几个类型作为参数传入，然后将其读取并打印：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] pub fn print_values(js_number: i32, js_boolean: bool, js_uint8_array: \u0026amp;[u8], js_number_array: Vec\u0026lt;i32\u0026gt;) { println!(\u0026#34;js number: {}\u0026#34;, js_number); println!(\u0026#34;js boolean: {}\u0026#34;, js_boolean); for item in js_uint8_array { println!(\u0026#34;js Uint8Array item: {}\u0026#34;, item); } for item in js_number_array { println!(\u0026#34;js number array item: {}\u0026#34;, item); } } 可以看到该函数传入了JS的number、boolean、Uint8Array和Array四个类型的参数。\n然后编译：\n1 wasm-pack build --target web 接着，在前端中引入函数并调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { print_values } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const jsNumber = 10; const jsBoolean = true; const jsUint8Array = new Uint8Array(3); jsUint8Array[0] = 1; jsUint8Array[1] = 2; jsUint8Array[2] = 3; const jsNumberArray = [30, 40, 50]; print_values(jsNumber, jsBoolean, jsUint8Array, jsNumberArray); } run(); \u0026lt;/script\u0026gt; 最后，启动http server并打开浏览器，在控制台可以看到\u0026hellip;看不到？！\n是的，没错，Rust的println!只会将打印的内容发送到Rust的标准输出流，而不是前端的控制台。如果想在控制台中打印，那么需要调用JS的console了。\n使用新的功能，第一步就是添加features，Cargo.toml中添加console如下：\n1 2 3 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;console\u0026#34;] } 在Rust中调用console.log()如下：\n1 web_sys::console::log_1(\u0026amp;\u0026#34;Hello, Rust!\u0026#34;.into()); 此处将其封装成一个函数：\n1 2 3 fn console_log(message: String) { web_sys::console::log_1(\u0026amp;message.into()); } 然后，将示例函数的println改成console_log()和format!，函数代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #[wasm_bindgen] pub fn print_values(js_number: i32, js_boolean: bool, js_uint8_array: \u0026amp;[u8], js_number_array: Vec\u0026lt;i32\u0026gt;) { console_log(format!(\u0026#34;js number: {}\u0026#34;, js_number)); console_log(format!(\u0026#34;js boolean: {}\u0026#34;, js_boolean)); for item in js_uint8_array { console_log(format!(\u0026#34;js Uint8Array item: {}\u0026#34;, item)); } for item in js_number_array { console_log(format!(\u0026#34;js number array item: {}\u0026#34;, item)); } } 最后，编译之后，打开浏览器，就可以在控制台看到输出：\n1 2 3 4 5 6 7 8 js number: 10 js boolean: true js Uint8Array item: 1 js Uint8Array item: 2 js Uint8Array item: 3 js number array item: 30 js number array item: 40 js number array item: 50 通用类型 Rust中提供了一个通用的类型——JsValue，可以作为任何JS类型。\n这里给一个简单的案例，设置一个函数，使用JsValue作为参数传入，并打印。\n创建函数：\n1 2 3 4 #[wasm_bindgen] pub fn print_js_value(val: JsValue) { console_log(format!(\u0026#34;{:?}\u0026#34;, val)); } 然后编译成wasm文件。\n在html中调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { print_js_value } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const jsNumber = 10; const jsBoolean = true; const jsUint8Array = new Uint8Array(3); jsUint8Array[0] = 1; jsUint8Array[1] = 2; jsUint8Array[2] = 3; const jsNumberArray = [30, 40, 50]; print_js_value(jsNumber); print_js_value(jsBoolean); print_js_value(jsUint8Array); print_js_value(jsNumberArray); } run(); \u0026lt;/script\u0026gt; 在html中，传入了不同类型的参数，但是在浏览器的控制台中可以看到，将所有不同类型的参数都打印出来了：\n1 2 3 4 JsValue(10) JsValue(true) JsValue(Uint8Array) JsValue([30, 40, 50]) Result Result在Rust中是一个很重要的存在，经常写Rust的话，也不想在写WebAssembly时改变开发习惯。\n其实对于JS而言，Result可以直接在catch中捕获到，只是说，这里我们需要定义好参数类型。\n使用Result返回报错 首先来一个只返回报错的场景：\n1 2 3 4 5 6 7 8 #[wasm_bindgen] pub fn only_return_error_when_result(count: i32) -\u0026gt; Result\u0026lt;(), JsError\u0026gt; { if count \u0026gt; 10 { Ok(()) } else { Err(JsError::new(\u0026#34;count \u0026lt; 10\u0026#34;)) } } 这里返回类型是Result，但是仅仅返回了一个错误。值得注意的是，这里的报错使用的类型是JsError，当然，这里也可以使用JsValue。\n然后在html调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { only_return_error_when_result } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); try { only_return_error_when_result(1); console.log(\u0026#39;1 is ok\u0026#39;); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 1: \u0026#39;, error); } try { only_return_error_when_result(100); console.log(\u0026#39;100 is ok\u0026#39;); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 100: \u0026#39;, error); } } run(); \u0026lt;/script\u0026gt; 这里调用了两次，第一次应当是错误的，第二次应该是正确的，并且都使用了catch来捕获错误。\n那么，在浏览器的控制台可以看到输出：\n1 2 An error is reported when the input parameter is 1: Error: count \u0026lt; 10 100 is ok 使用Result返回正常值和错误 那么，如果想既返回正常值，也想返回错误呢？Rust返回一个Result是没有问题，那么JS怎么解析呢？\n直接上Rust代码：\n1 2 3 4 5 6 7 8 #[wasm_bindgen] pub fn return_all_when_result(count: i32) -\u0026gt; Result\u0026lt;i32, JsError\u0026gt; { if count \u0026gt; 10 { Ok(count + 10) } else { Err(JsError::new(\u0026#34;count \u0026lt; 10\u0026#34;)) } } 该函数，获取到参数后，如果满足条件，加10后返回，否则报错。\n那么看看html中如何调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { return_all_when_result } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); try { const res = return_all_when_result(1); console.log(`get ${res}`); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 1: \u0026#39;, error); } try { const res = return_all_when_result(100); console.log(`get ${res}`); } catch(error) { console.log(\u0026#39;An error is reported when the input parameter is 100: \u0026#39;, error); } } run(); \u0026lt;/script\u0026gt; 是的，没错，正常获取就行了\u0026hellip;\u0026hellip;/捂脸哭\n这里的调用，依然是，第一个是错误的，第二个是正确返回值的，并且都使用了catch来捕获错误。\n最后，就是在浏览器的控制台中看到：\n1 2 An error is reported when the input parameter is 1: Error: count \u0026lt; 10 get 110 直接引入JS类型 如果你想更直接一点，那么可以直接引入JS类型！这里主要是利用js-sys这个依赖，可以在官方文档上看到很多JS的类型和函数，直接引入即可使用。当然，一定场景下，直接引入的类型，是需要手动转换类型的。\n配置依赖 在Cargo.toml中添加js-sys依赖：\n1 2 3 4 [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; web-sys = { version = \u0026#34;0.3.64\u0026#34;, features = [\u0026#34;Window\u0026#34;, \u0026#34;Document\u0026#34;, \u0026#34;Element\u0026#34;, \u0026#34;console\u0026#34;] } js-sys = \u0026#34;0.3.61\u0026#34; Uint8Array 首先以Uint8Array举例，在lib.rs头部引入类型：\n1 use js_sys::Uint8Array; 然后创建一个函数，参数和返回都是Uint8Array类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #[wasm_bindgen] pub fn print_uint8_array(js_arr: Uint8Array) -\u0026gt; Uint8Array { // new Uint8Array let mut arr = Uint8Array::new_with_length(3); // Uint8Array -\u0026gt; vec for (index, item) in js_arr.to_vec().iter().enumerate() { console_log(format!(\u0026#34;{} - the item in js_arr: {}\u0026#34;, index, item)); } // Avoid type conversion // Use the method of the type itself for index in 0..js_arr.length() { console_log(format!(\u0026#34;{} - the item in js_arr: {}\u0026#34;, index, js_arr.get_index(index))); } // vec -\u0026gt; Uint8Array let vec = vec![1, 2, 3]; let arr2 = Uint8Array::from(vec.as_slice()); arr = arr2.clone(); // Use the method of the type itself arr.set_index(0, 100); arr } 忽略该函数中无意义的逻辑和arr变量的警告，只是为了演示用法。\n可以在代码中看到，直接引入的Uint8Array有自己的方法，一定场景下，需要转换类型，但是最好避免进行类型转换，而直接使用其自带的方法。\n这里可以简要总结下，就是最好一定场景内全部使用直接引入的JS类型，或者直接全部使用Rust类型来代替JS类型，两者都存在场景下，手动转换类型是件很糟糕的事。\nDate Date类型，在上面的篇章中都没有提及，这里可以直接引入JS的Date类型来使用。\n首先是引入类型：\n1 use js_sys::Date; 然后，创建一个函数，返回时间戳：\n1 2 3 4 5 #[wasm_bindgen] pub fn return_time() -\u0026gt; f64 { let date = Date::new_0(); date.get_time() } 接着，在html中调用：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { return_time } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); console.log(\u0026#39;current time: \u0026#39;, return_time()); } run(); \u0026lt;/script\u0026gt; 最后，在浏览器的控制台中，可以看到：\n1 current time: 1686979932833 总结 本文中，主要讲述了如何使用Rust来实现DOM操作，读者可以根据方法自己去找到合适的方法，来实现自己的场景。其次，还讲述了Rust与JS的类型转换，从基础的各自类型的映射，到Rust独有的Result，到直接引入JS类型。当然这里需要注意的是，直接引入JS类型和Rust的基础类型映射JS类型这两种方法尽量不要混用，混用会导致需要手动类型转换，造成性能损耗。\n至此，又向Rust和WebAssembly整花活儿迈进了一步~😼\n","date":"2023-06-18T18:18:31Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/zh-cn/post/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%BA%8Cdom%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","title":"使用Rust和WebAssembly整花活儿(二)——DOM和类型转换"},{"content":"前言 WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。\n之前写过一篇文章，是关于如何使用golang来开发WebAssembly的——WebAssembly：未来前端开发的必备技能。\nRust和Go都可以用来开发WebAssembly，但它们有各自的优势和劣势。\nRust的优点：\n更快的性能和更小的二进制文件 更好的内存安全性 Go的优点：\n更容易上手和学习 更好的生态系统和社区支持 综合来说，如果你更注重性能和内存安全性，那么Rust可能是更好的选择。而如果你更注重开发效率和易用性，那么Go可能更适合你。当然，实际情况还需要根据具体的项目需求和团队情况来选择。\n因为一些工作需求，最近整了些rust的花活儿，这里系统地记录一下。当你遇到更注重性能和内存安全性的场景，希望这能有帮助。\n环境 Rust 1.70.0 wasm-bindgen 0.2.87 创建项目并添加依赖 此处默认已经安装Rust，需要安装的小伙伴儿可以参考官网。\n使用Cargo创建一个名为hello-wasm的项目：\n1 cargo new --lib hello-wasm 进入项目，打开文件Cargo.toml，添加依赖：\n1 2 3 4 5 [lib] crate-type = [\u0026#34;cdylib\u0026#34;] [dependencies] wasm-bindgen = \u0026#34;0.2.87\u0026#34; 更新lib.rs 默认创建项目中，存在一个名为lib.rs的文件，将内容全部替换成：\n1 2 3 4 5 6 use wasm_bindgen::prelude::*; #[wasm_bindgen] pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } 编译 至此，我们创建了一个最简单的功能——一个返回两个整数相加结果的函数。\n然后我们可以进行编译了，编译之前需要安装一个工具wasm-pack：\n1 cargo install wasm-pack 然后进行编译：\n1 wasm-pack build --target web 编译完成之后，将会多出来一个pkg文件夹，内容如下：\n1 2 3 4 5 6 pkg ├── hello_wasm.d.ts ├── hello_wasm.js ├── hello_wasm_bg.wasm ├── hello_wasm_bg.wasm.d.ts └── package.json 虽然文件很多，但是首先我们看到了我们所需要的wasm文件，并且，根据go的wasm引入方式，这里我们或许会需要用到js文件。\n前端引入 为了方便最快校验，直接在hello-wasm项目中创建index.html文件，来进行前端引入。\n创建index.html 那么，首先，创建index.html文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;使用Rust和WebAssembly整花活儿\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello, World! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 是的，没错！这是一场标准的开局！😼\n引入WASM 其实不同于go语言的wasm引入方式，Rust更希望直接引入js文件，而不是让开发者手动引入wasm文件。\n这里使用js引入：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; 完整代码 完整的html代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;使用Rust和WebAssembly整花活儿\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello, World! \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { add } from \u0026#39;./pkg/hello_wasm.js\u0026#39;; const run = async () =\u0026gt; { await init(); const result = add(1, 2); console.log(`the result from rust is: ${result}`); } run(); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 验证 这里可以快速起一个http server，这里我选择使用http-server，也可以使用python3 -m http.server这样的方式，看怎么各自的使用习惯。\n那么，启动http server：\n1 http-server 打开浏览器，访问http://localhost:8080，打开调试器，即可看到输出the result from rust is: 3，这就意味着迈出了整花活儿的第一步！\n常见问题 前端报响应类型错误 详细报错如下：\n1 Failed to load module script: The server responded with a non-JavaScript MIME type of \u0026#34;application/wasm\u0026#34;. Strict MIME type checking is enforced for module scripts per HTML spec. 当引入WebAssembly生成的js文件时，可能会遇到这个报错。报错乍一看是http server的响应问题，或者搜索时候，也会有帖子说这是一个response问题。\n实际上，当按照这个文章一步步操作时是不会有这个问题的，是因为本文的编译参数是直接解决了这个问题的。当我自己摸索的时候，解决这个问题真的是看到人都麻了……\n关键在于编译命令的参数：--target。\n当没有设置这个参数时，默认的参数其实是--target bundler，其是编译成给webpack之类的脚手架使用的。因此这里使用—target web，则是使其编译成可直接在web中使用。\n相关参数如下：\nbundler：编译成给webpack之类的脚手架使用 web：编译成web可直接使用 nodejs：编译成可通过require来加载的node模块 deno：编译成可通过import加载的deno模块 no-modules：跟web类似，但是更旧，且不能使用es模块 直接引入wasm文件 若此时尝试直接引入wasm文件，而不是使用本文所述的方式，那么你会发现，也是可行的！\n1 2 3 4 5 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; WebAssembly.instantiateStreaming(fetch(\u0026#34;./pkg/hello_wasm_bg.wasm\u0026#34;), {}).then( (obj) =\u0026gt; console.log(\u0026#39;the result from rust is: \u0026#39;, obj.instance.exports.add(1, 2)) ); \u0026lt;/script\u0026gt; 是的，没错，当前是可行的，但是当引入了一些别的比如dom之类的，就坏起来了……\n更新的wasm引入方式 上一问题中，且不说是否可以直接引入wasm文件，这里仅说一下，instantiateStreaming这个方法。这是一个更新的方法，无需转成arrayBuffer，这也是摸索Rust整活儿时候发现的。如果在别的语言引入wasm，请使用这个更新的方法吧。\n","date":"2023-06-14T17:32:28Z","image":"https://hunterji.com/img/cover.jpg","permalink":"https://hunterji.com/zh-cn/post/%E4%BD%BF%E7%94%A8rust%E5%92%8Cwebassembly%E6%95%B4%E8%8A%B1%E6%B4%BB%E5%84%BF%E4%B8%80%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","title":"使用Rust和WebAssembly整花活儿(一)——快速开始"},{"content":"前言 WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。\n快速上手 用go写一个hello world 1 2 3 4 5 6 7 8 9 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, WebAssembly!\u0026#34;) } 将go文件编译成wasm文件 1 GOOS=js GOARCH=wasm go build -o static/main.wasm 拷贝出wasm_exec.js 该文件为go的wasm的js支持文件\n1 cp \u0026#34;$(go env GOROOT)/misc/wasm/wasm_exec.js\u0026#34; static html文件调用wasm文件 1 2 3 4 5 6 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; 验证调用 浏览器加载html文件，f12打开控制台，可以看到wasm的打印消息。\ngo与js的类型转换 类型映射 1 2 3 4 5 6 7 8 9 10 | Go | JavaScript | | ---------------------- | ---------------------- | | js.Value | [its value] | | js.Func | function | | nil | null | | bool | boolean | | integers and floats | number | | string | string | | []interface{} | new array | | map[string]interface{} | new object | 如上为官方给出的go与js的类型映射表。\n比如在go中调用js函数，参数为array，那么就可以直接将go的[]interface{}类型的变量作为参数使用。\n函数转换数组 syscall/js提供了两个函数：\nCopyBytesToGo：func CopyBytesToGo(dst []byte, src Value) int CopyBytesToJS：func CopyBytesToJS(dst Value, src []byte) int 两者对于go而言，类型都是[]byte，但是对于js而言，需要Uint8Array或者Uint8ClampedArray类型，否则就会报错。\n那么，如何在go中生成一个Uint8Array或者Uint8ClampedArray类型的变量呢？官方的类型映射表也没有啊\u0026hellip;那么就看下一步。\n其余类型 对于非官方类型映射表内的类型，和官方提供的两个数据类型转换之外的类型，可以通过一种通用的方式来生成，以上一步的Uint8Array为例：\n1 js.Global().Get(\u0026#34;Uint8Array\u0026#34;).New(\u0026lt;length\u0026gt;) 实际使用案例：\n1 2 3 // goData []byte{...} jsData := js.Global().Get(\u0026#34;Uint8Array\u0026#34;).New(len(goData)) js.CopyBytesToJS(jsData, goData) 那么，比如js中的Date类型：\n1 2 dateConstructor := js.Global().Get(\u0026#34;Date\u0026#34;) dateConstructor.New(\u0026#34;2020-10-01\u0026#34;) 极端情况 好吧，还有最后一个方案，如果遇到极端情况，上述方案都无法解决，那么请转换成字符串吧！让go和js用各自的方法分别处理一波，得到自己想要的结果或者给出各自想给的数据。\njs调用go函数 此处需要在go中引入syscall/js，以实现js相关的操作。\n注册go函数 将go的函数注册为js的函数，由js来进行调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;syscall/js\u0026#34; func handleCount(this js.Value, args []js.Value) interface{} { count := args[0].Int() return js.ValueOf(count + 1) } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleEvent\u0026#34;, js.FuncOf(handleEvent)) \u0026lt;-done } js.Func() 接受一个函数类型作为其参数，该函数的定义是固定的：\n1 2 3 4 func(this Value, args []Value) interface{} // this 即 JavaScript 中的 this // args 是在 JavaScript 中调用该函数的参数列表。 // 返回值需用 js.ValueOf 映射成 JavaScript 的值 js.ValueOf返回作为js的值：\n1 2 3 4 5 6 7 8 9 10 | Go | JavaScript | | ---------------------- | ---------------------- | | js.Value | [its value] | | js.Func | function | | nil | null | | bool | boolean | | integers and floats | number | | string | string | | []interface{} | new array | | map[string]interface{} | new object | js调用 在js中使用也非常简单，引入wasm文件之后，直接调用函数即可。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { HandleEvent(1) // 传入参数1 }) \u0026lt;/script\u0026gt; go调用js函数 如果在js中本身已经定义了函数，那么在go中也可以直接调用该函数，进行运算，将得出的结果在go中继续使用。\n定义js函数 1 2 3 4 5 \u0026lt;script\u0026gt; function add(m, n) { return m + n } \u0026lt;/script\u0026gt; go中调用js函数 1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall/js\u0026#34; ) func main() { result := js.Global().Call(\u0026#34;add\u0026#34;, 1, 2) fmt.Println(result) // 此处输出类型为js.Value，无法直接使用 fmt.Println(result.Int() + 1) // 使用.Int()将其转换为go中的类型，即可直接使用 } 引入wasm 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; function add(m, n) { return m + n } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; 结果 在前端调试台可以看到输出：\n1 2 \u0026lt;number: 3\u0026gt; 4 第一个结果就是js.Value的值，第二个结果则是转换成go的值，并按照逻辑进行了+1处理。\n回调函数/解决go函数阻塞问题 The Go function fn is called with the value of JavaScript\u0026rsquo;s \u0026ldquo;this\u0026rdquo; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.\nInvoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.\nAs a consequence, if one wrapped function blocks, JavaScript\u0026rsquo;s event loop is blocked until that function returns. Hence, calling any async JavaScript API, which requires the event loop, like fetch (http.Client), will cause an immediate deadlock. Therefore a blocking function should explicitly start a new goroutine.\nsyscall/js官方文档表明，如果go包装函数阻塞，那么js的事件循环也将被阻塞，直到函数返回，调用任何需要事件循环（如fetch）的异步js api都导致立即死锁。因此，一个阻塞函数应该显式地启动一个新的协程。\n此处，可以在go中注册一个回调函数，加上协程实现异步，不会产生堵塞。\n注册函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall/js\u0026#34; \u0026#34;time\u0026#34; ) func handleRender(this js.Value, args []js.Value) interface{} { username := args[0].String() callback := args[len(args)-1] go func() { time.Sleep(3 * time.Second) callback.Invoke(fmt.Sprintf(\u0026#34;hello, %s !\u0026#34;, username)) }() fmt.Println(\u0026#34;waiting...\u0026#34;) return nil } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleRender\u0026#34;, js.FuncOf(handleRender)) \u0026lt;-done } js调用 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { HandleRender(\u0026#34;tom\u0026#34;, (message) =\u0026gt; console.log(\u0026#39;message: \u0026#39;, message)) }) \u0026lt;/script\u0026gt; 输出 在浏览器调试台，可以看到：\n1 2 waiting... // 先输出了waiting... hello, tom ! // 隔了3秒之后，输出了回调函数的值 Go实现Promise 上一步的回调函数，解决了函数阻塞问题，此处，结合回调函数实现promise，来丰富异步场景。\n在js中，promise是这样的：\n1 2 3 4 5 const message = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;hello, world !\u0026#34;) }, 3000) }) 使用async和await调用，拿到结果：\n1 2 3 4 5 6 7 8 9 10 async function printMessage() { const message = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;hello, world !\u0026#34;) }, 3000) }) const result = await message console.log(result) } 在go中又如何构建promise呢？这里可以用到上述go与js的类型转换，创建一个promise：\n1 js.Global().Get(\u0026#34;Promise\u0026#34;) 注册函数 go的完整实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall/js\u0026#34; \u0026#34;time\u0026#34; ) var document = js.Global().Get(\u0026#34;document\u0026#34;) func handleRender(this js.Value, args []js.Value) interface{} { handler := js.FuncOf(func(this js.Value, args []js.Value) interface{} { resolve := args[0] go func() { time.Sleep(3 * time.Second) resolve.Invoke(\u0026#34;hello, world !\u0026#34;) }() fmt.Println(\u0026#34;waiting...\u0026#34;) return nil }) promiseConstructor := js.Global().Get(\u0026#34;Promise\u0026#34;) return promiseConstructor.New(handler) } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleRender\u0026#34;, js.FuncOf(handleRender)) \u0026lt;-done } js调用 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script src=\u0026#34;static/wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(\u0026#34;static/main.wasm\u0026#34;), go.importObject) .then((result) =\u0026gt; go.run(result.instance)) \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, async () =\u0026gt; { const message = await HandleRender() console.log(\u0026#39;message: \u0026#39;, message) }) \u0026lt;/script\u0026gt; 输出 在浏览器调试台，可以看到：\n1 2 waiting... // 先输出了waiting... message: hello, world ! // 隔了3秒之后输出 操作DOM 使用document 定义一个全局的document\n1 var docuemnt = js.Global().Get(\u0026#34;document\u0026#34;) 获取元素 获取一个id为container的div，设置background-color: red、widht: 600、height: 400\n1 2 3 4 5 var containerElement = document.Call(\u0026#34;getElementById\u0026#34;, \u0026#34;container\u0026#34;) var containerElementStyle = container.Get(\u0026#34;style\u0026#34;) containerElementStyle.Set(\u0026#34;background\u0026#34;, \u0026#34;red\u0026#34;) containerElementStyle.Set(\u0026#34;width\u0026#34;, \u0026#34;600px\u0026#34;) containerElementStyle.Set(\u0026#34;height\u0026#34;, \u0026#34;400px\u0026#34;) 创建元素 创建一个id为image的image，设置width:300、height:200\n1 2 3 var imageElement = document.Call(\u0026#34;createElement\u0026#34;, \u0026#34;canvas\u0026#34;) imageElement.Set(\u0026#34;width\u0026#34;, 300) imageElement.Set(\u0026#34;width\u0026#34;, 200) 添加子元素 将image添加为id为container的div的子元素\n1 containerElement.Call(\u0026#34;appendChild\u0026#34;, imageElement) 添加事件 给image添加右击事件，右击image则阻止右键菜单\n1 2 3 4 5 6 7 8 // 定义响应函数 func handlePreventEventCallBack(this js.Value, args []js.Value) interface{} { args[0].Call(\u0026#34;preventDefault\u0026#34;) return false } // 给image添加事件 imageElement.Call(\u0026#34;addEventListener\u0026#34;, \u0026#34;contextmenu\u0026#34;, js.FuncOf(handlePreventEventCallBack)) 这里需要注意的是，当不再调用响应事件函数时，必须调用Func.Release以释放资源：\n1 2 3 4 5 6 7 var cb js.Func cb = js.FuncOf(func(this js.Value, args []js.Value) any { fmt.Println(\u0026#34;button clicked\u0026#34;) cb.Release() // 如果不再单击该按钮，则释放该函数 return nil }) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;myButton\u0026#34;).Call(\u0026#34;addEventListener\u0026#34;, \u0026#34;click\u0026#34;, cb) Canvas 这里放一波canvas的案例，包含了一些常用方法，可以参考完成更多操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( \u0026#34;math\u0026#34; \u0026#34;syscall/js\u0026#34; ) const ( width = 400 height = 400 radius = 200 ) var document = js.Global().Get(\u0026#34;document\u0026#34;) func handleRender(this js.Value, args []js.Value) interface{} { var canvas = document.Call(\u0026#34;getElementById\u0026#34;, \u0026#34;canvas\u0026#34;) canvas.Set(\u0026#34;width\u0026#34;, width) canvas.Set(\u0026#34;height\u0026#34;, height) var ctx = canvas.Call(\u0026#34;getContext\u0026#34;, \u0026#34;2d\u0026#34;) ctx.Call(\u0026#34;beginPath\u0026#34;) ctx.Call(\u0026#34;arc\u0026#34;, width/2, height/2, radius, 0, 2*math.Pi) ctx.Set(\u0026#34;fillStyle\u0026#34;, \u0026#34;lightpink\u0026#34;) ctx.Call(\u0026#34;fill\u0026#34;) ctx.Set(\u0026#34;lineWidth\u0026#34;, 2) ctx.Set(\u0026#34;strokeStyle\u0026#34;, \u0026#34;red\u0026#34;) ctx.Call(\u0026#34;stroke\u0026#34;) ctx.Set(\u0026#34;font\u0026#34;, \u0026#34;20px Comic Sans MS\u0026#34;) ctx.Set(\u0026#34;fillStyle\u0026#34;, \u0026#34;blue\u0026#34;) ctx.Call(\u0026#34;fillText\u0026#34;, \u0026#34;Hello, World !\u0026#34;, width/2-60, height/2) return nil } func main() { done := make(chan string, 0) js.Global().Set(\u0026#34;HandleRender\u0026#34;, js.FuncOf(handleRender)) \u0026lt;-done } 渲染结果：\n参考文档 syscall/js go wiki WebAssembly Go WebAssembly (Wasm) 简明教程 Go, WebAssembly, HTTP requests and Promises ","date":"2023-02-09T13:15:34Z","image":"https://hunterji.com/zh-cn/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8go%E6%9E%84%E5%BB%BAwebassembly/cover_hu15501836490561713388.jpg","permalink":"https://hunterji.com/zh-cn/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8go%E6%9E%84%E5%BB%BAwebassembly/","title":"如何使用Go构建WebAssembly"},{"content":"前言 因为项目需求，需要去检测用户的农历生日。虽然后来找到了合适的库，但是首先先解释下农历的定义，也是去了解才知道，原来农历不是阴历。\n农历属于阴阳合历，其年份分为平年和闰年。平年为十二个月，闰年为十三个月。月份分为大月和小月，大月三十天，小月二十九天，其平均历月等于一个朔望月。\n环境 Go 1.16 github.com/nosixtools/solarlunar 0.0.0 库 1 github.com/nosixtools/solarlunar 该库支持1900~2049年。所以项目要跑到2049年后的童鞋就要注意\u0026hellip;\u0026hellip;\n当然，该库还支持阳历转农历、节假日计算等，有兴趣大家可以自行去了解下。\n使用 判断闰年 该库不支持闰年判断，所以需要自己去实现闰年的判断，其参数类型为Boolean。\n1 2 3 4 5 6 7 func IsALeapYear(year int) (result bool) { if year%4 == 0 \u0026amp;\u0026amp; year%100 != 0 || year%400 == 0 { result = true return } return } 转换 需要转换的阳历日期格式是固定的，是2006-01-02。此处以农历2021-07-17为例。\n1 2 3 4 func main() { lunarDate := \u0026#34;2021-07-17\u0026#34; fmt.Println(solarlunar.LunarToSolar(lunarDate, IsALeapYear(time.Now().Year()))) } 输出为：\n1 2021-08-24 全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/nosixtools/solarlunar\u0026#34; ) func main() { lunarDate := \u0026#34;2021-07-17\u0026#34; fmt.Println(solarlunar.LunarToSolar(lunarDate, IsALeapYear(time.Now().Year()))) } func IsALeapYear(year int) (result bool) { if year%4 == 0 \u0026amp;\u0026amp; year%100 != 0 || year%400 == 0 { result = true return } return } ","date":"2021-08-31T09:08:57Z","image":"https://hunterji.com/zh-cn/post/golang%E5%AE%9E%E7%8E%B0%E5%86%9C%E5%8E%86%E8%BD%AC%E6%8D%A2%E9%98%B3%E5%8E%86/normal_hu3324909357741222847.jpg","permalink":"https://hunterji.com/zh-cn/post/golang%E5%AE%9E%E7%8E%B0%E5%86%9C%E5%8E%86%E8%BD%AC%E6%8D%A2%E9%98%B3%E5%8E%86/","title":"Golang实现农历转换阳历"}]